
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.WritableRaster;
import java.awt.image.*;
import java.awt.*;
import java.io.BufferedReader;
import java.io.File;
import java.util.Iterator;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.imageio.*;
import javax.swing.ImageIcon;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JSlider;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.filechooser.FileNameExtensionFilter;
import java.util.ArrayDeque;
import java.util.ArrayList;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @authors Raquel Escalante, Rafael Vasquez
 */
public class ImageEditor extends javax.swing.JFrame {
    
    // Creating a JLabel to display image.
    private JLabel imglabel;
    // Creating a file chooser to open files with
    private JFileChooser fcOpen;
    // Creating a file chooser to save files with
    private JFileChooser fcSave;
    // Properties of the Image
    private int format;
    private int width;
    private int height;
    private int maxColor;
    private BufferedImage img = null;
    // Hashmap and counter used to count unique colors
    private HashMap<Integer, Integer> uniqueCols;
    private int colorsCounter;
    private JSlider slider;
    private int bitspp;
    
    
    /**
     * Creates new form ImageEditor
     */
    public ImageEditor() {
        initComponents();
        
        imglabel = new JLabel();
        fcOpen = new JFileChooser();
        fcSave = new JFileChooser();
        // Creating file filters for the file choosers
        FileNameExtensionFilter imagesFilter = new FileNameExtensionFilter("Imágenes: *.bmp, *.pbm, *.pgm, *.ppm", "bmp", "pbm", "pgm", "ppm");
        FileNameExtensionFilter savingFilter = new FileNameExtensionFilter("Imágenes RLE: *.rle", "rle");
        fcOpen.addChoosableFileFilter(imagesFilter);
        fcOpen.addChoosableFileFilter(savingFilter);
        fcOpen.setFileFilter(imagesFilter);
        
//        fcSave.addChoosableFileFilter(savingFilter);
//        fcSave.setFileFilter(savingFilter);
        
        uniqueCols = new HashMap<>();
        colorsCounter = 0;
        slider = new JSlider(0, 255);
        bitspp = 0;
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jMenu1 = new javax.swing.JMenu();
        jMenuItem1 = new javax.swing.JMenuItem();
        ScrollPanePanel = new javax.swing.JPanel();
        jScrollPane = new javax.swing.JScrollPane();
        ImageInfoPanel = new javax.swing.JPanel();
        InfoPanel = new javax.swing.JPanel();
        InfoLabel = new javax.swing.JLabel();
        Dimensiones = new javax.swing.JLabel();
        BPP = new javax.swing.JLabel();
        Colores = new javax.swing.JLabel();
        DPI = new javax.swing.JLabel();
        HistoPanel = new javax.swing.JPanel();
        HistoLabel = new javax.swing.JLabel();
        GeneralHistogram = new javax.swing.JPanel();
        RedHistogram = new javax.swing.JPanel();
        GreenHistogram = new javax.swing.JPanel();
        BlueHistogram = new javax.swing.JPanel();
        GeneralLabel = new javax.swing.JLabel();
        RojoLabel = new javax.swing.JLabel();
        VerdeLabel = new javax.swing.JLabel();
        AzulLabel = new javax.swing.JLabel();
        BarraEstadoPanel = new javax.swing.JPanel();
        BarraEstado = new javax.swing.JPanel();
        Estado = new javax.swing.JLabel();
        MenuBar = new javax.swing.JMenuBar();
        MenuArchivo = new javax.swing.JMenu();
        AbrirArchivo = new javax.swing.JMenuItem();
        GuardarBMP = new javax.swing.JMenuItem();
        GuardarNetpbm = new javax.swing.JMenu();
        SinCompresion = new javax.swing.JMenuItem();
        CompresionRLE = new javax.swing.JMenuItem();
        MenuEditar = new javax.swing.JMenu();
        Negativo = new javax.swing.JMenuItem();
        BlancoNegro = new javax.swing.JMenuItem();
        EscalaDeGrises = new javax.swing.JMenuItem();
        Rotacion = new javax.swing.JMenu();
        Rotar90CW = new javax.swing.JMenuItem();
        Rotar90CCW = new javax.swing.JMenuItem();
        MenuFiltros = new javax.swing.JMenu();
        SuavizadoGaussiano = new javax.swing.JMenuItem();
        Ayuda = new javax.swing.JMenu();
        Readme = new javax.swing.JMenuItem();
        About = new javax.swing.JMenuItem();

        jMenu1.setText("jMenu1");

        jMenuItem1.setText("jMenuItem1");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Editor de Imagenes | by Raquel Escalante & Rafael Vasquez");
        setBounds(new java.awt.Rectangle(0, 0, 800, 600));
        setMaximumSize(getMaximumSize());

        jScrollPane.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        jScrollPane.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        jScrollPane.setDoubleBuffered(true);
        jScrollPane.setPreferredSize(new java.awt.Dimension(1011, 1));

        InfoPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(102, 102, 102)));

        InfoLabel.setText("Información de la imagen");

        Dimensiones.setFont(new java.awt.Font("Dialog", 1, 10)); // NOI18N
        Dimensiones.setText("Dimensiones: ");

        BPP.setFont(new java.awt.Font("Dialog", 1, 10)); // NOI18N
        BPP.setText("Bits por pixel:");

        Colores.setFont(new java.awt.Font("Dialog", 1, 10)); // NOI18N
        Colores.setText("Colores únicos:");

        DPI.setFont(new java.awt.Font("Dialog", 1, 10)); // NOI18N
        DPI.setText("Puntos por pulgada (dpi):");

        javax.swing.GroupLayout InfoPanelLayout = new javax.swing.GroupLayout(InfoPanel);
        InfoPanel.setLayout(InfoPanelLayout);
        InfoPanelLayout.setHorizontalGroup(
            InfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(InfoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(InfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(InfoLabel)
                    .addGroup(InfoPanelLayout.createSequentialGroup()
                        .addGap(12, 12, 12)
                        .addGroup(InfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(BPP)
                            .addComponent(Dimensiones)
                            .addComponent(Colores)
                            .addComponent(DPI))))
                .addContainerGap(55, Short.MAX_VALUE))
        );
        InfoPanelLayout.setVerticalGroup(
            InfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(InfoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(InfoLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(Dimensiones)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(BPP)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(Colores)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(DPI)
                .addContainerGap(20, Short.MAX_VALUE))
        );

        HistoPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(102, 102, 102)));

        HistoLabel.setText("Histogramas");

        GeneralHistogram.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(102, 102, 102)));

        javax.swing.GroupLayout GeneralHistogramLayout = new javax.swing.GroupLayout(GeneralHistogram);
        GeneralHistogram.setLayout(GeneralHistogramLayout);
        GeneralHistogramLayout.setHorizontalGroup(
            GeneralHistogramLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        GeneralHistogramLayout.setVerticalGroup(
            GeneralHistogramLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 103, Short.MAX_VALUE)
        );

        RedHistogram.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(102, 102, 102)));

        javax.swing.GroupLayout RedHistogramLayout = new javax.swing.GroupLayout(RedHistogram);
        RedHistogram.setLayout(RedHistogramLayout);
        RedHistogramLayout.setHorizontalGroup(
            RedHistogramLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        RedHistogramLayout.setVerticalGroup(
            RedHistogramLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 82, Short.MAX_VALUE)
        );

        GreenHistogram.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(102, 102, 102)));

        javax.swing.GroupLayout GreenHistogramLayout = new javax.swing.GroupLayout(GreenHistogram);
        GreenHistogram.setLayout(GreenHistogramLayout);
        GreenHistogramLayout.setHorizontalGroup(
            GreenHistogramLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        GreenHistogramLayout.setVerticalGroup(
            GreenHistogramLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 82, Short.MAX_VALUE)
        );

        BlueHistogram.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(102, 102, 102)));

        javax.swing.GroupLayout BlueHistogramLayout = new javax.swing.GroupLayout(BlueHistogram);
        BlueHistogram.setLayout(BlueHistogramLayout);
        BlueHistogramLayout.setHorizontalGroup(
            BlueHistogramLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        BlueHistogramLayout.setVerticalGroup(
            BlueHistogramLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 82, Short.MAX_VALUE)
        );

        GeneralLabel.setFont(new java.awt.Font("Dialog", 1, 10)); // NOI18N
        GeneralLabel.setText("General");

        RojoLabel.setFont(new java.awt.Font("Dialog", 1, 10)); // NOI18N
        RojoLabel.setText("Rojo");

        VerdeLabel.setFont(new java.awt.Font("Dialog", 1, 10)); // NOI18N
        VerdeLabel.setText("Verde");

        AzulLabel.setFont(new java.awt.Font("Dialog", 1, 10)); // NOI18N
        AzulLabel.setText("Azul");

        javax.swing.GroupLayout HistoPanelLayout = new javax.swing.GroupLayout(HistoPanel);
        HistoPanel.setLayout(HistoPanelLayout);
        HistoPanelLayout.setHorizontalGroup(
            HistoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(HistoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(HistoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(GeneralHistogram, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(RedHistogram, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(BlueHistogram, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(GreenHistogram, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(HistoPanelLayout.createSequentialGroup()
                        .addGroup(HistoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(HistoLabel)
                            .addComponent(VerdeLabel)
                            .addComponent(RojoLabel)
                            .addComponent(AzulLabel)
                            .addComponent(GeneralLabel))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        HistoPanelLayout.setVerticalGroup(
            HistoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(HistoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(HistoLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(GeneralHistogram, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(GeneralLabel)
                .addGap(19, 19, 19)
                .addComponent(RedHistogram, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(RojoLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(GreenHistogram, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(VerdeLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(BlueHistogram, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(AzulLabel)
                .addContainerGap(32, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout ImageInfoPanelLayout = new javax.swing.GroupLayout(ImageInfoPanel);
        ImageInfoPanel.setLayout(ImageInfoPanelLayout);
        ImageInfoPanelLayout.setHorizontalGroup(
            ImageInfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, ImageInfoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(ImageInfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(HistoPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(InfoPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        ImageInfoPanelLayout.setVerticalGroup(
            ImageInfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(ImageInfoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(InfoPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(HistoPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        javax.swing.GroupLayout ScrollPanePanelLayout = new javax.swing.GroupLayout(ScrollPanePanel);
        ScrollPanePanel.setLayout(ScrollPanePanelLayout);
        ScrollPanePanelLayout.setHorizontalGroup(
            ScrollPanePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(ScrollPanePanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 886, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(ImageInfoPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        ScrollPanePanelLayout.setVerticalGroup(
            ScrollPanePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(ScrollPanePanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(ImageInfoPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
            .addComponent(jScrollPane, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        BarraEstado.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        Estado.setText("Bienvenido");

        javax.swing.GroupLayout BarraEstadoLayout = new javax.swing.GroupLayout(BarraEstado);
        BarraEstado.setLayout(BarraEstadoLayout);
        BarraEstadoLayout.setHorizontalGroup(
            BarraEstadoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(BarraEstadoLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(Estado)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        BarraEstadoLayout.setVerticalGroup(
            BarraEstadoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(BarraEstadoLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(Estado)
                .addContainerGap())
        );

        javax.swing.GroupLayout BarraEstadoPanelLayout = new javax.swing.GroupLayout(BarraEstadoPanel);
        BarraEstadoPanel.setLayout(BarraEstadoPanelLayout);
        BarraEstadoPanelLayout.setHorizontalGroup(
            BarraEstadoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(BarraEstadoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(BarraEstado, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        BarraEstadoPanelLayout.setVerticalGroup(
            BarraEstadoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(BarraEstadoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(BarraEstado, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        MenuArchivo.setText("Archivo");

        AbrirArchivo.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        AbrirArchivo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Open16.gif"))); // NOI18N
        AbrirArchivo.setText("Abrir Imagen...");
        AbrirArchivo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AbrirArchivoActionPerformed(evt);
            }
        });
        MenuArchivo.add(AbrirArchivo);

        GuardarBMP.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        GuardarBMP.setIcon(new javax.swing.ImageIcon(getClass().getResource("/SaveBMP.gif"))); // NOI18N
        GuardarBMP.setText("Guardar BMP");
        GuardarBMP.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                GuardarBMPActionPerformed(evt);
            }
        });
        MenuArchivo.add(GuardarBMP);

        GuardarNetpbm.setText("Guardar Netpbm");

        SinCompresion.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.SHIFT_MASK));
        SinCompresion.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Save16.gif"))); // NOI18N
        SinCompresion.setText("Sin Compresión");
        SinCompresion.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SinCompresionActionPerformed(evt);
            }
        });
        GuardarNetpbm.add(SinCompresion);

        CompresionRLE.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        CompresionRLE.setIcon(new javax.swing.ImageIcon(getClass().getResource("/SaveRLE.gif"))); // NOI18N
        CompresionRLE.setText("Con compresión RLE");
        CompresionRLE.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CompresionRLEActionPerformed(evt);
            }
        });
        GuardarNetpbm.add(CompresionRLE);

        MenuArchivo.add(GuardarNetpbm);

        MenuBar.add(MenuArchivo);

        MenuEditar.setText("Editar");

        Negativo.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_N, java.awt.event.InputEvent.CTRL_MASK));
        Negativo.setText("Negativo");
        Negativo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                NegativoActionPerformed(evt);
            }
        });
        MenuEditar.add(Negativo);

        BlancoNegro.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_B, java.awt.event.InputEvent.CTRL_MASK));
        BlancoNegro.setText("Blanco y Negro");
        BlancoNegro.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                BlancoNegroActionPerformed(evt);
            }
        });
        MenuEditar.add(BlancoNegro);

        EscalaDeGrises.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_G, java.awt.event.InputEvent.CTRL_MASK));
        EscalaDeGrises.setText("Escala de Grises");
        EscalaDeGrises.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                EscalaDeGrisesActionPerformed(evt);
            }
        });
        MenuEditar.add(EscalaDeGrises);

        Rotacion.setText("Rotación");

        Rotar90CW.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_RIGHT, java.awt.event.InputEvent.CTRL_MASK));
        Rotar90CW.setText("90° CW");
        Rotar90CW.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Rotar90CWActionPerformed(evt);
            }
        });
        Rotacion.add(Rotar90CW);

        Rotar90CCW.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_LEFT, java.awt.event.InputEvent.CTRL_MASK));
        Rotar90CCW.setText("90° CCW");
        Rotar90CCW.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Rotar90CCWActionPerformed(evt);
            }
        });
        Rotacion.add(Rotar90CCW);

        MenuEditar.add(Rotacion);

        MenuBar.add(MenuEditar);

        MenuFiltros.setText("Filtros");

        SuavizadoGaussiano.setText("Suavizado Gaussiano");
        SuavizadoGaussiano.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SuavizadoGaussianoActionPerformed(evt);
            }
        });
        MenuFiltros.add(SuavizadoGaussiano);

        MenuBar.add(MenuFiltros);

        Ayuda.setText("Ayuda");

        Readme.setText("Léeme");
        Readme.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ReadmeActionPerformed(evt);
            }
        });
        Ayuda.add(Readme);

        About.setText("Acerca De...");
        About.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AboutActionPerformed(evt);
            }
        });
        Ayuda.add(About);

        MenuBar.add(Ayuda);

        setJMenuBar(MenuBar);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(ScrollPanePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
            .addComponent(BarraEstadoPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(ScrollPanePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(BarraEstadoPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    
    /**
     * 
     * @param evt 
     */
    
    private void writeRLEFile(String filename){
        int currentColor;
        int inColor;
        int counter = 0;
        if (img != null){
            try(FileWriter fw = new FileWriter(filename + ".rle")) {
                // Initializing the data with a header according to the format
                switch(format){
                    case 1:
                        fw.write("P1 \n" + width + " " + height + "\n");
                        break;
                    case 2:
                        fw.write("P2 \n" + width + " " + height + "\n");
                        break;
                    case 3:
                        fw.write("P3 \n" + width + " " + height + "\n");
                }
                // This function will create a big array with all the pixel RGB values.
                int[] pixelDataBuffInt = img.getRGB(0, 0, width, height, null, 0, width);
                int maxSize = pixelDataBuffInt.length;

                // Initializing the very first pixel value
                currentColor = pixelDataBuffInt[0];

                for(int i = 0; i < maxSize; i++){
                    // Reading next pixel value
                    inColor = pixelDataBuffInt[i];

                    // If the colors are different write the count to the file and reset
                    if ( inColor != currentColor ){
                        //Writing data to the file according to the format
                        switch(format){
                            case 1: //1 = Black and 0 = White
                                if (((currentColor >> 16) & 0xff) == 0){
                                    fw.write(counter + " 1 ");
                                }else{
                                    fw.write(counter + " 0 ");
                                }
                                break;
                            case 2: // Just the red value.
                                fw.write(counter + " " + ((currentColor >> 16) & 0xff) + " ");
                                break;
                            case 3: // Red, green and blue values together as the same int value.
                                fw.write(counter + " " + currentColor  + " ");   // red, green and blue
                        }

                        currentColor = inColor;
                        counter = 1;
                    }else{
                        counter++;
                    }
                }
                //Writing the last color ocurrence to the file according to the format
                switch(format){
                    case 1: //1 = Black and 0 = White
                        if (((currentColor >> 16) & 0xff) == 0){
                            fw.write(counter + " 1 ");
                        }else{
                            fw.write(counter + " 0 ");
                        }
                        break;
                    case 2: // Just the red value.
                        fw.write(counter + " " + ((currentColor >> 16) & 0xff) + " ");
                        break;
                    case 3: // Red, green and blue values.
                        fw.write(counter + " " + currentColor  + " ");   // red, green and blue
                }

                fw.close();
                Estado.setText("Imagen guardada en: " + filename + ".rle");
            }catch (IOException ex) {
                    Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }

    private void writeNetPBMFile(String filename){
        String ext = "";
        switch(format){
            case 1:
                ext = ".pbm";
                break;
            case 2:
                ext = ".pgm";
                break;
            case 3:
                ext = ".ppm";
        }
        
        if (img != null){
            try(FileWriter fw = new FileWriter(filename + ext)) {
//                long startTime = System.currentTimeMillis();

                // Initializing the data with a header according to the format
                switch(format){
                    case 1:
                        fw.write("P1 \n" + width + " " + height);
                        break;
                    case 2:
                        fw.write("P2 \n" + width + " " + height + " \n" + maxColor);
                        break;
                    case 3:
                        fw.write("P3 \n" + width + " " + height + " \n" + maxColor);
                }
                // This function will create a big array with all the pixel RGB values.
                int[] pixelDataBuffInt = img.getRGB(0, 0, width, height, null, 0, width);

                int maxSize = pixelDataBuffInt.length;
//                long endTime = System.currentTimeMillis();
//                System.out.println("That took " + (endTime - startTime) + " milliseconds");
                for(int i = 0; i < maxSize; i++){
                    // Adding end of line after each row.
                    if (i % width == 0){
                        fw.write("\n");
                    }

                    //Writing data to the file according to the format
                    switch(format){
                        case 1: //1 = Black and 0 = White
                            if (((pixelDataBuffInt[i] >> 16) & 0xff) == 0){
                                fw.write(" 1 ");
                            }else{
                                fw.write(" 0 ");
                            }
                            break;
                        case 2: // Just the red value.
                            fw.write(((pixelDataBuffInt[i] >> 16) & 0xff) + " ");
                            break;
                        case 3: // Red, green and blue values.   
                            fw.write(((pixelDataBuffInt[i] >> 16) & 0xff) + " ");   // red
                            fw.write(((pixelDataBuffInt[i] >> 8) & 0xff) + " ");    // green
                            fw.write((pixelDataBuffInt[i] & 0xff) + " ");           // blue
                    }
                    
                }
//                endTime = System.currentTimeMillis();
//                System.out.println("That took " + (endTime - startTime) + " milliseconds");
                fw.close();
                Estado.setText("Imagen guardada en: " + filename + ext);
            }catch (IOException ex) {
                    Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
    
    private void countUniqueColors(){
        int key;
        if (img != null){
            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                    // Unpacking the color data of each pixel.
                    key = img.getRGB(x,y);
                    
                    // If the color has not been counted.
                    if (uniqueCols.get(key) == null){
                        uniqueCols.put(key, 1);
                        colorsCounter++;
                    } 
                }
            }
        }
    }
    
    private void updateDimensions(){
        if (img != null){
            width = img.getWidth();
            height = img.getHeight();
        } 
    }
    
    private void getBitsPerPixel(){
        if (img != null){
            if (format == 3) {
                ColorModel cm = img.getColorModel();
                bitspp = cm.getPixelSize();
            }else if (format == 2){
                bitspp = 8;
            }else if (format == 1){
                bitspp = 1;
            }
        }
    }
    
    /*private void getDPI() {
    if (img != null) {
    
    }
    }*/
    
    private void createHistogramBins(){
        //Function to set the contents of the histogram bins
        
    }
    
    private BufferedImage readPBMfromRLE(int width, int height, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int value = 0;
        int row = 0;
        int col = 0;
        int freq = 0;
        while (parser.ttype != StreamTokenizer.TT_EOF){
            try {
                // Reading next token:
                //System.out.println( " 1)current parser value: " + parser.nval );
                parser.nextToken();
                freq = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            if (parser.ttype == StreamTokenizer.TT_EOF){
                //System.out.println( " End of file "  );
                break;
            }
            try {
                // Reading next token:
                parser.nextToken();
                value = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            if (value == 1){
                value = 0;
            }else{
                value = 255;
            }
            for(int i = 0; i<freq; i++ ){
                raster.setSample(col, row, 0, value);
                raster.setSample(col, row, 1, value);
                raster.setSample(col, row, 2, value);
                col++;
                if (col >= width){
                    col = 0;
                    row++;
                }
            }  
        }
        
        return imgTemp;
    }
    
    private BufferedImage readPGMfromRLE(int width, int height, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int value = 0;
        int row = 0;
        int col = 0;
        int freq = 0;
        //int numTokens = 0;
        while (parser.ttype != StreamTokenizer.TT_EOF){
            try {
                // Reading next token:
                //System.out.println( " 1)current parser value: " + parser.nval );
                parser.nextToken();
                freq = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            if (parser.ttype == StreamTokenizer.TT_EOF){
                //System.out.println( " End of file "  );
                break;
            }
            try {
                // Reading next token:
                parser.nextToken();
                value = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            
            
            for(int i = 0; i<freq; i++ ){
                try{
                    raster.setSample(col, row, 0, value); // R
                    raster.setSample(col, row, 1, value); // G
                    raster.setSample(col, row, 2, value); // B
                    col++;
                    if (col >= width){
                        col = 0;
                        row++;
                    }
                }catch(ArrayIndexOutOfBoundsException e){
                    //System.out.println( "Width: "+ width + "  Height: " + height + "  c: " + col + "  r: " + row + " freq: " + freq + " val: " + value);
                    JOptionPane.showMessageDialog(this, "La imagen está corrompida.");
                    break;
                }
            }  
        }
        return imgTemp;
    }
    
    private BufferedImage readPPMfromRLE(int width, int height, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int value = 0;
        int row = 0;
        int col = 0;
        int freq = 0;
        while (parser.ttype != StreamTokenizer.TT_EOF){
            try {
                // Reading next token:
                //System.out.println( " 1)current parser value: " + parser.nval );
                parser.nextToken();
                freq = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            if (parser.ttype == StreamTokenizer.TT_EOF){
                //System.out.println( " End of file "  );
                break;
            }
            try {
                // Reading next token:
                parser.nextToken();
                value = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            
            int r = (value >> 16) & 0xff;
            int g = (value >> 8) & 0xff;
            int b = value & 0xff;
            
            for(int i = 0; i<freq; i++ ){
                raster.setSample(col, row, 0, r); // R
                raster.setSample(col, row, 1, g); // G
                raster.setSample(col, row, 2, b); // B
                col++;
                if (col >= width){
                    col = 0;
                    row++;
                }
            }  
        }
        return imgTemp;
    }
    
    private BufferedImage readPPM(int width, int height, int maxCol, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int value;
        for (int y = 0; y < height; ++y)
            for (int x = 0; x < width; ++x)
                for (int i = 0; i < 3; ++i) {

                    try {
                       // Reading next token:
                       parser.nextToken();
                    } catch (IOException ex) {
                        Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    // If the current token is eof before reading all the width and height of bytes then exit.
                    if (parser.ttype == StreamTokenizer.TT_EOF){
                        JOptionPane.showMessageDialog(this, "La imagen está posiblemente truncada");
                        return null;
                    }
                    // If the current token is not a number then exit.
                    if (parser.ttype != StreamTokenizer.TT_NUMBER){
                        JOptionPane.showMessageDialog(this, "Valor no numerico para la muestra" + i + " del pixel en (" + x + "," + y + ")");
                        return null;
                    }
                    // Rasterizing the data
                    value = ((int)parser.nval * 255)/ maxCol;
                    raster.setSample(x, y, i, value);
                }
        return imgTemp;
    }

    private BufferedImage readPGM(int width, int height,int maxCol, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int pixelValue;
        for (int y = 0; y < height; ++y)
            for (int x = 0; x < width; ++x)
                for (int i = 0; i < 1; ++i) {
                    try {
                       // Reading next token:
                       parser.nextToken();
                    } catch (IOException ex) {
                        Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    // If the current token is eof before reading all the width and height of bytes then exit.
                    if (parser.ttype == StreamTokenizer.TT_EOF){
                        JOptionPane.showMessageDialog(this, "La imagen está posiblemente truncada");
                        return null;
                    }
                    // If the current token is not a number then exit.
                    if (parser.ttype != StreamTokenizer.TT_NUMBER){
                        JOptionPane.showMessageDialog(this, "Valor no numerico para la muestra" + i + " del pixel en (" + x + "," + y + ")");
                        return null;
                    }
                    // Resterizingthe data
                    pixelValue = ((int)parser.nval * 255)/ maxCol;
                    raster.setSample(x, y, 0, pixelValue);// R
                    raster.setSample(x, y, 1, pixelValue);// G
                    raster.setSample(x, y, 2, pixelValue);// B
                }
        return imgTemp;
    }
        
    private BufferedImage readPBM(int width, int height, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int pixelValue;
        for (int y = 0; y < height; ++y)
            for (int x = 0; x < width; ++x)
                for (int i = 0; i < 1; ++i) {

                    try {
                       // Reading next token:
                       parser.nextToken();
                    } catch (IOException ex) {
                        Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    // If the current token is eof before reading all the width and height of bytes then exit.
                    if (parser.ttype == StreamTokenizer.TT_EOF){
                        JOptionPane.showMessageDialog(this, "La imagen está posiblemente truncada");
                        return null;
                    }
                    // If the current token is not a number then exit.
                    if (parser.ttype != StreamTokenizer.TT_NUMBER){
                        JOptionPane.showMessageDialog(this, "Valor no numerico para la muestra" + i + " del pixel en (" + x + "," + y + ")");
                        return null;
                    }
                    // Rasterizing the data and inverting values because 1 = black and 0 = white in this format.
                    pixelValue = (int)parser.nval ;
                    if (pixelValue == 1){
                        raster.setSample(x, y, 0, 0);
                        raster.setSample(x, y, 1, 0);
                        raster.setSample(x, y, 2, 0);
                    }else{
                        raster.setSample(x, y, 0, 255);
                        raster.setSample(x, y, 1, 255);
                        raster.setSample(x, y, 2, 255);
                    }
                    
                }
        return imgTemp;
    }
    
    private int convolutionFunction(int krnlVal, int[] kernl, ArrayList r, ArrayList g, ArrayList b){
        int krnlSize = kernl.length;
        int rTotal = 0;
        int gTotal = 0;
        int bTotal = 0;
        // If all the kernels have the same length then we can convolute.
        if(krnlSize == r.size() && r.size() == g.size() && g.size() == b.size()){
            for(int i = 0 ; i < krnlSize; i++){
                rTotal += (int)r.get(i) * kernl[i];
                gTotal += (int)g.get(i) * kernl[i];
                bTotal += (int)b.get(i) * kernl[i];
            }

            rTotal /= krnlVal;
            gTotal /= krnlVal;
            bTotal /= krnlVal;
        }else{
        // Error: Can't calculate convolution.
        }
        return (255<<24) | (rTotal<<16) | (gTotal<<8) | bTotal;
    }
    
    //Function to set parameters of B&W slider
    private JSlider getSlider(JOptionPane SliderPane) {
        JSlider sliderAux = new JSlider(0, 255);
        sliderAux.setMajorTickSpacing(50);
        sliderAux.setPaintTicks(true);
        sliderAux.setPaintLabels(true);
        ChangeListener changeListener = new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent changeEvent) {
                JSlider theSlider = (JSlider) changeEvent.getSource();
                if (!theSlider.getValueIsAdjusting()) {
                    SliderPane.setInputValue(new Integer(theSlider.getValue()));
                }
            }
        };
        sliderAux.addChangeListener(changeListener);
        return sliderAux;
    }
    
    private void GuardarBMPActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_GuardarBMPActionPerformed
        // TODO add your handling code here:
        int returnVal;
        
        if ( img != null ){
            returnVal = fcSave.showSaveDialog(this); 
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
            return;
        }
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            
            try {
                //RenderedImage rendImage = bi;
                ImageIO.write(img, "bmp", new File(fcSave.getSelectedFile().getAbsolutePath()+".bmp"));
                Estado.setText("Imagen guardada en: " + fcSave.getSelectedFile().getAbsolutePath()+".bmp");
            } catch ( IOException e) {
                e.printStackTrace();
            }
        }
        
    }//GEN-LAST:event_GuardarBMPActionPerformed

    private void AbrirArchivoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AbrirArchivoActionPerformed
        // TODO add your handling code here:
        // The image variable
        img = null;
        // Resetting unique colors container for new image.
        uniqueCols.clear();
        colorsCounter = 0;
        bitspp = 0;
        
        FileInputStream in = null;
        StreamTokenizer parser;
        BufferedReader reader;
        //In response to a button click, the file chooser is displayed
        int returnVal = fcOpen.showOpenDialog(this);
        
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File file = fcOpen.getSelectedFile();
            // Now open the file.
            //JOptionPane.showMessageDialog(this, file.getAbsolutePath());
            // Getting the image extension.
            String path = file.getAbsolutePath();
            String extension = path.substring(path.length() - 3);
            
            if(null != extension){
                // Are we opening a bmp image?
                switch (extension) {
                    case "bmp":
                        try {
                            // Filling BufferedImage with file information
                            img = ImageIO.read(file);
                            // Making note of image properties
                            format = 3;
                            width = img.getWidth();
                            height = img.getHeight();
                            maxColor = 255;
                            //JOptionPane.showMessageDialog(this, "Imagen tipo: " + types);
                        } catch (IOException e) {
                            // Report exceptions
                            JOptionPane.showMessageDialog(this, "Error al Abrir Imagen!");
                        }
                        break;
                        //log.append("Opening: " + file.getName() + "." + newline);
                    // Are we opening a Netpbm image?
                    case "ppm":
                    case "pgm":
                    case "pbm":
                        // Creating a FileInputStream to be used by the BufferedReader
                        
                        try {
                            in = new FileInputStream( path );
                        } catch (FileNotFoundException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }

                        
                        reader = new BufferedReader(new InputStreamReader(in));
                        parser = new StreamTokenizer(reader);
                        // Filtering out comments from the data
                        parser.commentChar('#');

                        try {
                            // Reading Header(Magic Number):
                           parser.nextToken();
                        } catch (IOException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }

                        // Processing the magic number. (Pending verify this is actually a String)
                        switch(parser.sval){
                            // PBM format
                            case "P1":
                                format = 1;
                                maxColor = 1;
                                break;
                            case "P2":
                                format = 2;
                                break;
                            case "P3":
                                format = 3;
                                break;
                        }

                        //JOptionPane.showMessageDialog(this, format );

                        // Reading image properties from header: Width, Height, max color(optional)
                        try {
                            // Reading Header:
                           parser.nextToken();
                           width = (int)parser.nval;
                           parser.nextToken();
                           height = (int)parser.nval;

                           if (format != 1){
                               parser.nextToken();
                               maxColor = (int)parser.nval;
                           }
                        } catch (IOException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }
                        //JOptionPane.showMessageDialog(this, "W:" + width + " H:" + height + " MaxC:" + maxColor);

                        // Proceeding to read the image data 
                        switch(format){
                            case 1:
                                img = readPBM(width, height, parser);
                                break;
                            case 2:
                                img = readPGM(width, height, maxColor, parser);
                                break;
                            case 3:
                                img = readPPM(width, height, maxColor, parser);
                                break;
                        }
                        break;
                    case "rle":
                        try {
                            in = new FileInputStream( path );
                        } catch (FileNotFoundException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }

                        reader = new BufferedReader(new InputStreamReader(in));
                        parser = new StreamTokenizer(reader);

                        try {
                            // Reading Header(Magic Number):
                           parser.nextToken();
                        } catch (IOException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }

                        // Processing the magic number. (Pending verify this is actually a String)
                        switch(parser.sval){
                            // PBM format
                            case "P1":
                                format = 1;
                                maxColor = 1;
                                break;
                            case "P2":
                                format = 2;
                                break;
                            case "P3":
                                format = 3;
                                break;
                        }

                        //JOptionPane.showMessageDialog(this, format );

                        // Reading image properties from header: Width, Height, max color(optional)
                        try {
                            // Reading Header:
                           parser.nextToken();
                           width = (int)parser.nval;
                           parser.nextToken();
                           height = (int)parser.nval;
                        } catch (IOException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }
                        //JOptionPane.showMessageDialog(this, "W:" + width + " H:" + height + " MaxC:" + maxColor);

                        // Proceeding to read the image data 
                        switch(format){
                            case 1:
                                img = readPBMfromRLE(width, height, parser);
                                break;
                            case 2:
                                img = readPGMfromRLE(width, height, parser);
                                break;
                            case 3:
                                img = readPPMfromRLE(width, height, parser);
                                break;
                        }
                        break;
                }
                
                ImageIcon icon = new ImageIcon(img);
                // Adding the ImageIcon to the Label.
                imglabel.setIcon( icon );
                //Aligning the image to the center.
                imglabel.setHorizontalAlignment(JLabel.CENTER);
                //Adding the label to the Scrolling pane.
                jScrollPane.getViewport().add(imglabel);

                // Counting unique colors
                countUniqueColors();
                getBitsPerPixel();
                
                //Changing Estado Label
                Estado.setText("Abriendo " + file.getAbsolutePath() );
                Colores.setText("Colores únicos: "+colorsCounter);
                Dimensiones.setText("Dimensiones: " + width + "x" + height);
                BPP.setText("Bits por pixel: " + bitspp);    
            }
        } else {
            // Cancel opening.
            //JOptionPane.showMessageDialog(this, "Opening file canceled.");
            //log.append("Open command cancelled by user." + newline);
        }
    }//GEN-LAST:event_AbrirArchivoActionPerformed

    private void NegativoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_NegativoActionPerformed
        // TODO add your handling code here:
        if (img != null){
            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                    // Unpacking the data of each pixel with masks.
                    int p = img.getRGB(x, y);
                    int a = (p >> 24) & 0xff;
                    int r = (p >> 16) & 0xff;
                    int g = (p >> 8) & 0xff;
                    int b = p & 0xff;

                    // Inverting the colors of the pixel per sample.
                    r = 255 - r;
                    g = 255 - g;
                    b = 255 - b;

                    // Packing back the pixel data
                    p = (a<<24) | (r<<16) | (g<<8) | b;
                    img.setRGB(x, y, p);

                    // Repainting the scroll pane to update the changes
                    jScrollPane.repaint();
                    // Updating status bar.
                    Estado.setText("Aplicando Negativo");
                    Colores.setText("Colores únicos: "+colorsCounter);
                }
            }    
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_NegativoActionPerformed

    private void CompresionRLEActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CompresionRLEActionPerformed
        int returnVal;

        if ( img != null ){
            returnVal = fcSave.showSaveDialog(this);
            if (returnVal == JFileChooser.APPROVE_OPTION) {
                if (format >= 1 && format <= 3)
                    writeRLEFile(fcSave.getSelectedFile().getAbsolutePath());
                else
                   JOptionPane.showMessageDialog(this, "¡ERROR: Error de Formato!");
            }
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
            return;
        }
    }//GEN-LAST:event_CompresionRLEActionPerformed

    private void EscalaDeGrisesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_EscalaDeGrisesActionPerformed
        // TODO add your handling code here:
        if (img != null){
            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                    int avg;
                    // Unpacking the data of each pixel with masks.
                    int p = img.getRGB(x,y);
                    int a = (p>>24)&0xff;
                    int r = (p>>16)&0xff;
                    int g = (p>>8)&0xff;
                    int b = p&0xff;
                    
                    //Calculating average per pixel
                    avg = (r+g+b)/3;
                    
                    // Packing back the pixel data
                    p = (a<<24) | (avg<<16) | (avg<<8) | avg;
                    img.setRGB(x, y, p);
                            
                    //Repainting scroll pane to update the changes
                    jScrollPane.repaint();                                      
                }
            }
            //Calculate Unique Colors and Update Status Bar
            uniqueCols.clear();
            colorsCounter = 0;
            countUniqueColors();
            format = 2;
            Estado.setText("Aplicando Escala de Grises");
            Colores.setText("Colores únicos: "+colorsCounter);
            Dimensiones.setText("Dimensiones: " + width + "x" + height);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_EscalaDeGrisesActionPerformed

    private void SinCompresionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SinCompresionActionPerformed
        int returnVal;

        if ( img != null ){
            returnVal = fcSave.showSaveDialog(this);
            if (returnVal == JFileChooser.APPROVE_OPTION) {
                if (format >= 1 && format <= 3)
                    writeNetPBMFile(fcSave.getSelectedFile().getAbsolutePath());
                else
                   JOptionPane.showMessageDialog(this, "¡ERROR: Error de Formato!"); 
            }
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
            return;
        } 
    }//GEN-LAST:event_SinCompresionActionPerformed

    private void BlancoNegroActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BlancoNegroActionPerformed
        // TODO add your handling code here:
        //Adding JOptionPane and initializing slider for input
        if (img != null){
            JOptionPane SliderPane = new JOptionPane();
            slider = getSlider(SliderPane);
            SliderPane.setMessage(new Object[] { "Valor del umbral: ", slider });
            SliderPane.setMessageType(JOptionPane.QUESTION_MESSAGE);
            SliderPane.setOptionType(JOptionPane.OK_CANCEL_OPTION);
            JDialog dialog;
            dialog = SliderPane.createDialog(jScrollPane, "Umbral");
            dialog.setVisible(true);

            /*Input Dialog for testing
            String aux = JOptionPane.showInputDialog("Umbral: ");
            int thr;
            thr = Integer.parseInt(aux);*/

            //getting threshold from slider
            int thr;
            //If there's no value from slider and it's unininitialized, assign just half the value
            if (SliderPane.getInputValue() == JOptionPane.UNINITIALIZED_VALUE){
                thr = 127;
            }else{            
                thr = (int)SliderPane.getInputValue();
            }
        
            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                    
                    int avg;
                    // Unpacking the data of each pixel with masks.
                    int p = img.getRGB(x,y);
                    int a = (p>>24)&0xff;
                    int r = (p>>16)&0xff;
                    int g = (p>>8)&0xff;
                    int b = p&0xff;
                    
                    //Calculating average per pixel
                    avg = (r+g+b)/3;
					
                    //Sorting average into range according to threshold
                    if (avg < thr){
                        avg = 0;
                    }else{
                        avg = 255;
                    }
                    //Packing back the pixel data
                    p = (a<<24) | (avg<<16) | (avg<<8) | avg;
                    img.setRGB(x, y, p);
                            
                    //Repainting scroll pane to update the changes
                    jScrollPane.repaint();
                }
            }
            //Calculate Unique Colors and Update Status Bar
            uniqueCols.clear();
            colorsCounter = 0;
            countUniqueColors();
            format = 1;
            Estado.setText("Aplicando Blanco y Negro");
            Colores.setText("Colores únicos: "+colorsCounter);
            Dimensiones.setText("Dimensiones: " + width + "x" + height);
            
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_BlancoNegroActionPerformed

    private void Rotar90CWActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Rotar90CWActionPerformed
        //Declaring an auxiliary image for operations with Width and Height inverted
        if (img != null){
            int imgW = img.getWidth();
            int imgH = img.getHeight();
            //Declaring an auxiliary image for operations with Width and Height inverted
            BufferedImage imgAux = new BufferedImage(imgH, imgW, BufferedImage.TYPE_3BYTE_BGR);
            for (int i = 0; i < imgW; i++){
                for(int j = 0; j < imgH; j++){
                    imgAux.setRGB(imgH - j - 1, i, img.getRGB(i, j));
                }
            }
            img = imgAux;
            ImageIcon icon = new ImageIcon(img);
            // Adding the ImageIcon to the Label.
            imglabel.setIcon( icon );
            //Aligning the image to the center.
            imglabel.setHorizontalAlignment(JLabel.CENTER);
            //Adding the label to the Scrolling pane.
            jScrollPane.getViewport().add(imglabel);
            updateDimensions();
            Estado.setText("Aplicando Rotación 90°CW");
            Colores.setText("Colores únicos: "+colorsCounter);
            Dimensiones.setText("Dimensiones: " + width + "x" + height);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
        
        
    }//GEN-LAST:event_Rotar90CWActionPerformed

    private void Rotar90CCWActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Rotar90CCWActionPerformed
        // TODO add your handling code here:
        //Declaring an auxiliary image for operations with Width and Height inverted
        BufferedImage imgAux = null;
        if (img != null){
            int imgW = img.getWidth();
            int imgH = img.getHeight();
            //assigning imgAux
            imgAux = new BufferedImage(imgH, imgW, img.getType());
            for (int i = 0; i < imgW; i++){
                for(int j = 0; j < imgH; j++){
                    imgAux.setRGB(j, imgW - 1 - i, img.getRGB(i, j));
                }
            }
            img = imgAux;
            ImageIcon icon = new ImageIcon(img);
            // Adding the ImageIcon to the Label.
            imglabel.setIcon( icon );
            //Aligning the image to the center.
            imglabel.setHorizontalAlignment(JLabel.CENTER);
            //Adding the label to the Scrolling pane.
            jScrollPane.getViewport().add(imglabel);
            updateDimensions();
            Estado.setText("Aplicando Rotación 90°CCW");
            Colores.setText("Colores únicos: "+colorsCounter);
            Dimensiones.setText("Dimensiones: " + width + "x" + height);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
        
    }//GEN-LAST:event_Rotar90CCWActionPerformed

    private void ReadmeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ReadmeActionPerformed
        // TODO add your handling code here:
        Runtime rt = Runtime.getRuntime();
        String readme = ("README.txt");
        try {
            Process p = rt.exec("notepad "+readme);
        } catch (IOException ex) {
            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_ReadmeActionPerformed

    private void AboutActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AboutActionPerformed
        // TODO add your handling code here:
        JOptionPane.showMessageDialog(this, "Editor de Imágenes\nRaquel Escalante y Rafael Vasquez\nSemestre 2-2017\nProcesamiento Digital De Imágenes", "Acerca de", JOptionPane.INFORMATION_MESSAGE);
        
    }//GEN-LAST:event_AboutActionPerformed

    private void SuavizadoGaussianoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SuavizadoGaussianoActionPerformed
        
        if (img != null){
            BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
            int kernelSize = 5;
            int kernelValue = 16;
            int[] kernel = {1, 4, 6, 4, 1};
            int i;
            int j;
            int k;
            int pvalue;
            // These Deques serve as sliding windows per color channel.
            ArrayList redL = new ArrayList();
            ArrayList greenL = new ArrayList();
            ArrayList blueL = new ArrayList();
            //This cycles choose the pivot pixel and where to write in the temp image. (Row by Row)
            for(i = 0; i < height; i++){
                redL.clear();
                greenL.clear();
                blueL.clear();
                // The values outside of the kernel are equal to 0
                for(k = 0; k < kernelSize/2; k++){
                    redL.add(0);
                    greenL.add(0);
                    blueL.add(0);
                }
                for(k = 0; k < kernelSize/2 + 1; k++){
                    pvalue = img.getRGB(k, i);
                    redL.add((pvalue >> 16) & 0xff);
                    greenL.add((pvalue >> 8) & 0xff);
                    blueL.add(pvalue & 0xff);
                }
                
                for(j = 0; j < width; j++){
                    int newPixelValue = convolutionFunction(kernelValue, kernel, redL, greenL, blueL);
                    imgTemp.setRGB(j, i, newPixelValue);
                    // Shifting sliding windows to the right by one pixel, if the kernel is out of bounds, complete with 0's.
                    if (j + 1 + kernelSize/2 >= width){
                        redL.add(0);
                        greenL.add(0);
                        blueL.add(0);
                    }else{
                        pvalue = img.getRGB(j + 1 + kernelSize / 2, i);
                        redL.add((pvalue >> 16) & 0xff);
                        greenL.add((pvalue >> 8) & 0xff);
                        blueL.add(pvalue & 0xff);
                    }
                    
                    redL.remove(0);
                    greenL.remove(0);
                    blueL.remove(0);
                }
            }
            
            img = imgTemp;
            ImageIcon icon = new ImageIcon(img);
            // Adding the ImageIcon to the Label.
            imglabel.setIcon( icon );
            //Aligning the image to the center.
            imglabel.setHorizontalAlignment(JLabel.CENTER);
            //Adding the label to the Scrolling pane.
            jScrollPane.getViewport().add(imglabel);
            // Repainting the scroll pane to update the changes
            jScrollPane.repaint();
            // Recounting colors
            countUniqueColors();
            // Updating status bar.
            Estado.setText("Aplicando Suavizado Gaussiano | Colores Únicos en imagen: " + colorsCounter);
            
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_SuavizadoGaussianoActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ImageEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ImageEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ImageEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ImageEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            new ImageEditor().setVisible(true);
        });
        
        
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem About;
    private javax.swing.JMenuItem AbrirArchivo;
    private javax.swing.JMenu Ayuda;
    private javax.swing.JLabel AzulLabel;
    private javax.swing.JLabel BPP;
    private javax.swing.JPanel BarraEstado;
    private javax.swing.JPanel BarraEstadoPanel;
    private javax.swing.JMenuItem BlancoNegro;
    private javax.swing.JPanel BlueHistogram;
    private javax.swing.JLabel Colores;
    private javax.swing.JMenuItem CompresionRLE;
    private javax.swing.JLabel DPI;
    private javax.swing.JLabel Dimensiones;
    private javax.swing.JMenuItem EscalaDeGrises;
    private javax.swing.JLabel Estado;
    private javax.swing.JPanel GeneralHistogram;
    private javax.swing.JLabel GeneralLabel;
    private javax.swing.JPanel GreenHistogram;
    private javax.swing.JMenuItem GuardarBMP;
    private javax.swing.JMenu GuardarNetpbm;
    private javax.swing.JLabel HistoLabel;
    private javax.swing.JPanel HistoPanel;
    private javax.swing.JPanel ImageInfoPanel;
    private javax.swing.JLabel InfoLabel;
    private javax.swing.JPanel InfoPanel;
    private javax.swing.JMenu MenuArchivo;
    private javax.swing.JMenuBar MenuBar;
    private javax.swing.JMenu MenuEditar;
    private javax.swing.JMenu MenuFiltros;
    private javax.swing.JMenuItem Negativo;
    private javax.swing.JMenuItem Readme;
    private javax.swing.JPanel RedHistogram;
    private javax.swing.JLabel RojoLabel;
    private javax.swing.JMenu Rotacion;
    private javax.swing.JMenuItem Rotar90CCW;
    private javax.swing.JMenuItem Rotar90CW;
    private javax.swing.JPanel ScrollPanePanel;
    private javax.swing.JMenuItem SinCompresion;
    private javax.swing.JMenuItem SuavizadoGaussiano;
    private javax.swing.JLabel VerdeLabel;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JScrollPane jScrollPane;
    // End of variables declaration//GEN-END:variables

}