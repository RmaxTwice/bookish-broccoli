import java.awt.image.BufferedImage;
import java.awt.image.WritableRaster;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.image.ColorModel;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JSlider;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JSpinner;
import javax.swing.SpinnerNumberModel;
import javax.swing.AbstractButton;
import javax.swing.ButtonGroup;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import MyUtils.*;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Raquel Escalante
 * @author Rafael Vasquez
 */
public class ImageEditor extends javax.swing.JFrame {
    // Creating filter controller class
    private final FiltersController myFilters;
    // Creating a JLabel to display image.
    private final JLabel imglabel;
    // Creating more jLabels for histograms
    private final JLabel rLabel;
    private final JLabel grLabel;
    private final JLabel bLabel;
    // Creating a file chooser to open files with
    private final JFileChooser fcOpen;
    // Creating a file chooser to save files with
    private final JFileChooser fcSave;
    // Properties of the Image
    private int format;
    private int width;
    private int height;
    private int maxColor;
    private BufferedImage imgZoom = null;
    private BufferedImage img = null;
    // Hashmap and counter used to count unique colors
    private final HashMap<Integer, Integer> uniqueCols;
    private int colorsCounter;
    private final JSlider thresholdSlider;
    private final JSlider kernelSizeSlider;
    //Integer to show bits per pixel
    private int bitspp;
    //Histogram bins
    private int [] GrayBins;
    private int [] RedBins;
    private int [] GreenBins;
    private int [] BlueBins;
    
    /**
     * Creates new form ImageEditor
     */
    public ImageEditor() {
        initComponents();
        
        myFilters = new FiltersController();
        imglabel = new JLabel();
				//Labels for histograms;
        rLabel = new JLabel();
        grLabel = new JLabel();
        bLabel = new JLabel();
				bitspp = 0;
        fcOpen = new JFileChooser();
        fcSave = new JFileChooser();
        // Creating file filters for the file choosers
        FileNameExtensionFilter imagesFilter = new FileNameExtensionFilter("Imágenes: *.bmp, *.pbm, *.pgm, *.ppm", "bmp", "pbm", "pgm", "ppm");
        FileNameExtensionFilter savingFilter = new FileNameExtensionFilter("Imágenes RLE: *.rle", "rle");
        fcOpen.addChoosableFileFilter(imagesFilter);
        fcOpen.addChoosableFileFilter(savingFilter);
        fcOpen.setFileFilter(imagesFilter);
        
//        fcSave.addChoosableFileFilter(savingFilter);
//        fcSave.setFileFilter(savingFilter);
        
        uniqueCols = new HashMap<>();
        colorsCounter = 0;
        // Configuring some Slider's properties.
        thresholdSlider = new JSlider(0, 255, 127); // min, max, init
        thresholdSlider.setMajorTickSpacing(50);
        thresholdSlider.setPaintTicks(true);
        thresholdSlider.setPaintLabels(true);
        
        // Configuring some Slider's properties.
        kernelSizeSlider = new JSlider(2, 7, 5); // min, max, init
        kernelSizeSlider.setMajorTickSpacing(1);
        kernelSizeSlider.setPaintTicks(true);
        kernelSizeSlider.setPaintLabels(true);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        jMenu1 = new javax.swing.JMenu();
        jMenuItem1 = new javax.swing.JMenuItem();
        jMenuItem2 = new javax.swing.JMenuItem();
        jMenuItem3 = new javax.swing.JMenuItem();
        jMenu2 = new javax.swing.JMenu();
        ScrollPanePanel = new javax.swing.JPanel();
        jScrollPane = new javax.swing.JScrollPane();
        ImageInfoPanel = new javax.swing.JPanel();
        InfoPanel = new javax.swing.JPanel();
        InfoLabel = new javax.swing.JLabel();
        Dimensiones = new javax.swing.JLabel();
        BPP = new javax.swing.JLabel();
        Colores = new javax.swing.JLabel();
        DPI = new javax.swing.JLabel();
        HistoPanel = new javax.swing.JPanel();
        HistoLabel = new javax.swing.JLabel();
        RedHistogram = new javax.swing.JPanel();
        GreenHistogram = new javax.swing.JPanel();
        BlueHistogram = new javax.swing.JPanel();
        RojoLabel = new javax.swing.JLabel();
        VerdeLabel = new javax.swing.JLabel();
        AzulLabel = new javax.swing.JLabel();
        BarraEstadoPanel = new javax.swing.JPanel();
        BarraEstado = new javax.swing.JPanel();
        Estado = new javax.swing.JLabel();
        MenuBar = new javax.swing.JMenuBar();
        MenuArchivo = new javax.swing.JMenu();
        AbrirArchivo = new javax.swing.JMenuItem();
        GuardarBMP = new javax.swing.JMenuItem();
        GuardarNetpbm = new javax.swing.JMenu();
        SinCompresion = new javax.swing.JMenuItem();
        CompresionRLE = new javax.swing.JMenuItem();
        MenuEditar = new javax.swing.JMenu();
        Rotacion = new javax.swing.JMenu();
        Rotar90CW = new javax.swing.JMenuItem();
        Rotar90CCW = new javax.swing.JMenuItem();
        RotacionLibre = new javax.swing.JMenuItem();
        Escalamiento = new javax.swing.JMenuItem();
        MenuVer = new javax.swing.JMenu();
        Zoom = new javax.swing.JMenuItem();
        MenuFiltros = new javax.swing.JMenu();
        ColorMenu = new javax.swing.JMenu();
        Negativo = new javax.swing.JMenuItem();
        EscalaDeGrises = new javax.swing.JMenuItem();
        BlancoNegro = new javax.swing.JMenuItem();
        SuavizadoMenu = new javax.swing.JMenu();
        SuavizadoGaussiano = new javax.swing.JMenuItem();
        SuavizadoPromedio = new javax.swing.JMenuItem();
        Mediana = new javax.swing.JMenuItem();
        jSeparator1 = new javax.swing.JPopupMenu.Separator();
        DetectarBordesMenu = new javax.swing.JMenu();
        Roberts = new javax.swing.JMenuItem();
        Sobel = new javax.swing.JMenuItem();
        Prewitt = new javax.swing.JMenuItem();
        Laplaciano = new javax.swing.JMenuItem();
        jSeparator2 = new javax.swing.JPopupMenu.Separator();
        Personalizado = new javax.swing.JMenuItem();
        Ayuda = new javax.swing.JMenu();
        Readme = new javax.swing.JMenuItem();
        About = new javax.swing.JMenuItem();

        jMenu1.setText("jMenu1");

        jMenuItem1.setText("jMenuItem1");

        jMenuItem2.setText("jMenuItem2");

        jMenuItem3.setText("jMenuItem3");

        jMenu2.setText("jMenu2");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Editor de Imagenes | by Raquel Escalante & Rafael Vasquez");
        setBounds(new java.awt.Rectangle(0, 0, 800, 600));
        setMaximumSize(getMaximumSize());

        jScrollPane.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        jScrollPane.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        jScrollPane.setDoubleBuffered(true);
        jScrollPane.setPreferredSize(new java.awt.Dimension(1011, 1));

				InfoPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(102, 102, 102)));

        InfoLabel.setText("Información de la imagen");

        Dimensiones.setFont(new java.awt.Font("Dialog", 1, 10)); // NOI18N
        Dimensiones.setText("Dimensiones: ");

        BPP.setFont(new java.awt.Font("Dialog", 1, 10)); // NOI18N
        BPP.setText("Bits por pixel:");

        Colores.setFont(new java.awt.Font("Dialog", 1, 10)); // NOI18N
        Colores.setText("Colores únicos:");

        DPI.setFont(new java.awt.Font("Dialog", 1, 10)); // NOI18N
        DPI.setText("Puntos por pulgada (dpi):");

        javax.swing.GroupLayout InfoPanelLayout = new javax.swing.GroupLayout(InfoPanel);
        InfoPanel.setLayout(InfoPanelLayout);
        InfoPanelLayout.setHorizontalGroup(
            InfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(InfoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(InfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(InfoLabel)
                    .addGroup(InfoPanelLayout.createSequentialGroup()
                        .addGap(12, 12, 12)
                        .addGroup(InfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(BPP)
                            .addComponent(Dimensiones)
                            .addComponent(Colores)
                            .addComponent(DPI))))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        InfoPanelLayout.setVerticalGroup(
            InfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(InfoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(InfoLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(Dimensiones)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(BPP)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(Colores)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(DPI)
                .addContainerGap(20, Short.MAX_VALUE))
        );

        HistoPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(102, 102, 102)));

        HistoLabel.setText("Histogramas");

        RedHistogram.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(102, 102, 102)));
        RedHistogram.setLayout(new java.awt.BorderLayout());

        GreenHistogram.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(102, 102, 102)));
        GreenHistogram.setLayout(new java.awt.BorderLayout());

        BlueHistogram.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(102, 102, 102)));
        BlueHistogram.setLayout(new java.awt.BorderLayout());

        RojoLabel.setFont(new java.awt.Font("Dialog", 1, 10)); // NOI18N
        RojoLabel.setText("-");

        VerdeLabel.setFont(new java.awt.Font("Dialog", 1, 10)); // NOI18N
        VerdeLabel.setText("-");
        VerdeLabel.setToolTipText("");

        AzulLabel.setFont(new java.awt.Font("Dialog", 1, 10)); // NOI18N
        AzulLabel.setText("-");

        javax.swing.GroupLayout HistoPanelLayout = new javax.swing.GroupLayout(HistoPanel);
        HistoPanel.setLayout(HistoPanelLayout);
        HistoPanelLayout.setHorizontalGroup(
            HistoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(HistoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(HistoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(BlueHistogram, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 280, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(GreenHistogram, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 280, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(HistoPanelLayout.createSequentialGroup()
                        .addGroup(HistoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(HistoLabel)
                            .addComponent(RojoLabel)
                            .addComponent(AzulLabel)
                            .addComponent(RedHistogram, javax.swing.GroupLayout.PREFERRED_SIZE, 280, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(VerdeLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        HistoPanelLayout.setVerticalGroup(
            HistoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(HistoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(HistoLabel)
                .addGap(18, 18, 18)
                .addComponent(RedHistogram, javax.swing.GroupLayout.PREFERRED_SIZE, 122, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(RojoLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(GreenHistogram, javax.swing.GroupLayout.PREFERRED_SIZE, 122, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(VerdeLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(BlueHistogram, javax.swing.GroupLayout.PREFERRED_SIZE, 122, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(AzulLabel)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout ImageInfoPanelLayout = new javax.swing.GroupLayout(ImageInfoPanel);
        ImageInfoPanel.setLayout(ImageInfoPanelLayout);
        ImageInfoPanelLayout.setHorizontalGroup(
            ImageInfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, ImageInfoPanelLayout.createSequentialGroup()
                .addGroup(ImageInfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(HistoPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(InfoPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        ImageInfoPanelLayout.setVerticalGroup(
            ImageInfoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(ImageInfoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(InfoPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(HistoPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout ScrollPanePanelLayout = new javax.swing.GroupLayout(ScrollPanePanel);
        ScrollPanePanel.setLayout(ScrollPanePanelLayout);
        ScrollPanePanelLayout.setHorizontalGroup(
            ScrollPanePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(ScrollPanePanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 811, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(ImageInfoPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        ScrollPanePanelLayout.setVerticalGroup(
            ScrollPanePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(ScrollPanePanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(ImageInfoPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        BarraEstado.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        Estado.setText("Bienvenido");

        javax.swing.GroupLayout BarraEstadoLayout = new javax.swing.GroupLayout(BarraEstado);
        BarraEstado.setLayout(BarraEstadoLayout);
        BarraEstadoLayout.setHorizontalGroup(
            BarraEstadoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(BarraEstadoLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(Estado)
                .addContainerGap(928, Short.MAX_VALUE))
        );
        BarraEstadoLayout.setVerticalGroup(
            BarraEstadoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(BarraEstadoLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(Estado)
                .addContainerGap())
        );

        javax.swing.GroupLayout BarraEstadoPanelLayout = new javax.swing.GroupLayout(BarraEstadoPanel);
        BarraEstadoPanel.setLayout(BarraEstadoPanelLayout);
        BarraEstadoPanelLayout.setHorizontalGroup(
            BarraEstadoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(BarraEstadoPanelLayout.createSequentialGroup()
                .addComponent(BarraEstado, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        BarraEstadoPanelLayout.setVerticalGroup(
            BarraEstadoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(BarraEstadoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(BarraEstado, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        MenuArchivo.setText("Archivo");

        AbrirArchivo.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        AbrirArchivo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Open16.gif"))); // NOI18N
        AbrirArchivo.setText("Abrir Imagen...");
        AbrirArchivo.addActionListener(this::AbrirArchivoActionPerformed);
        MenuArchivo.add(AbrirArchivo);

        GuardarBMP.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        GuardarBMP.setIcon(new javax.swing.ImageIcon(getClass().getResource("/SaveBMP.gif"))); // NOI18N
        GuardarBMP.setText("Guardar BMP");
        GuardarBMP.addActionListener(this::GuardarBMPActionPerformed);
        MenuArchivo.add(GuardarBMP);

        GuardarNetpbm.setText("Guardar Netpbm");

        SinCompresion.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.SHIFT_MASK));
        SinCompresion.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Save16.gif"))); // NOI18N
        SinCompresion.setText("Sin Compresión");
        SinCompresion.addActionListener(this::SinCompresionActionPerformed);
        GuardarNetpbm.add(SinCompresion);

        CompresionRLE.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        CompresionRLE.setIcon(new javax.swing.ImageIcon(getClass().getResource("/SaveRLE.gif"))); // NOI18N
        CompresionRLE.setText("Con compresión RLE");
        CompresionRLE.addActionListener(this::CompresionRLEActionPerformed);
        GuardarNetpbm.add(CompresionRLE);

        MenuArchivo.add(GuardarNetpbm);

        MenuBar.add(MenuArchivo);

        MenuEditar.setText("Editar");

        Rotacion.setText("Rotación");

        Rotar90CW.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_RIGHT, java.awt.event.InputEvent.CTRL_MASK));
        Rotar90CW.setText("90° CW");
        Rotar90CW.addActionListener(this::Rotar90CWActionPerformed);
        Rotacion.add(Rotar90CW);

        Rotar90CCW.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_LEFT, java.awt.event.InputEvent.CTRL_MASK));
        Rotar90CCW.setText("90° CCW");
        Rotar90CCW.addActionListener(this::Rotar90CCWActionPerformed);
        Rotacion.add(Rotar90CCW);

        RotacionLibre.setText("Libre");
        RotacionLibre.addActionListener(this::RotacionLibreActionPerformed);
        Rotacion.add(RotacionLibre);

        MenuEditar.add(Rotacion);

        Escalamiento.setText("Escalamiento");
        Escalamiento.addActionListener(this::EscalamientoActionPerformed);
        MenuEditar.add(Escalamiento);

        MenuBar.add(MenuEditar);

        MenuVer.setText("Ver");

        Zoom.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Z, java.awt.event.InputEvent.ALT_MASK));
        Zoom.setText("Aplicar Zoom");
        Zoom.addActionListener(this::ZoomActionPerformed);
        MenuVer.add(Zoom);

        MenuBar.add(MenuVer);

        MenuFiltros.setText("Filtros");

        ColorMenu.setText("Color");

        Negativo.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_N, java.awt.event.InputEvent.CTRL_MASK));
        Negativo.setText("Negativo");
        Negativo.addActionListener(this::NegativoActionPerformed);
        ColorMenu.add(Negativo);

        EscalaDeGrises.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_G, java.awt.event.InputEvent.CTRL_MASK));
        EscalaDeGrises.setText("Escala de Grises");
        EscalaDeGrises.addActionListener(this::EscalaDeGrisesActionPerformed);
        ColorMenu.add(EscalaDeGrises);

        BlancoNegro.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_B, java.awt.event.InputEvent.CTRL_MASK));
        BlancoNegro.setText("Blanco y Negro");
        BlancoNegro.addActionListener(this::BlancoNegroActionPerformed);
        ColorMenu.add(BlancoNegro);

        MenuFiltros.add(ColorMenu);

        SuavizadoMenu.setText("Suavizado");

        SuavizadoGaussiano.setText("Suavizado Gaussiano");
        SuavizadoGaussiano.addActionListener(this::SuavizadoGaussianoActionPerformed);
        SuavizadoMenu.add(SuavizadoGaussiano);

        SuavizadoPromedio.setText("Suavizado Promedio");
        SuavizadoPromedio.addActionListener(this::SuavizadoPromedioActionPerformed);
        SuavizadoMenu.add(SuavizadoPromedio);

        Mediana.setText("Mediana");
        Mediana.addActionListener(this::MedianaActionPerformed);
        SuavizadoMenu.add(Mediana);

        MenuFiltros.add(SuavizadoMenu);
        MenuFiltros.add(jSeparator1);

        DetectarBordesMenu.setText("Deteccion de Bordes");

        Roberts.setText("Roberts");
        Roberts.addActionListener(this::RobertsActionPerformed);
        DetectarBordesMenu.add(Roberts);

        Sobel.setText("Sobel");
        Sobel.addActionListener(this::SobelActionPerformed);
        DetectarBordesMenu.add(Sobel);

        Prewitt.setText("Prewitt");
        Prewitt.addActionListener(this::PrewittActionPerformed);
        DetectarBordesMenu.add(Prewitt);

        Laplaciano.setText("Laplaciano del Gaussiano");
        Laplaciano.addActionListener(this::LaplacianoActionPerformed);
        DetectarBordesMenu.add(Laplaciano);

        MenuFiltros.add(DetectarBordesMenu);
        MenuFiltros.add(jSeparator2);

        Personalizado.setText("Personalizado");
        Personalizado.addActionListener(this::PersonalizadoActionPerformed);
        MenuFiltros.add(Personalizado);

        MenuBar.add(MenuFiltros);

        Ayuda.setText("Ayuda");

        Readme.setText("Léeme");
        Readme.addActionListener(this::ReadmeActionPerformed);
        Ayuda.add(Readme);

        About.setText("Acerca De...");
        About.addActionListener(this::AboutActionPerformed);
        Ayuda.add(About);

        MenuBar.add(Ayuda);

        setJMenuBar(MenuBar);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(ScrollPanePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(BarraEstadoPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(ScrollPanePanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(BarraEstadoPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(5, 5, 5))
        );

        pack();
    }// </editor-fold>                                              
    
    
    /**
     * 
     * @param evt 
     */
    
    private static BufferedImage duplicate3BYTEBGR(BufferedImage image) {
        if (image == null){
            throw new NullPointerException();
        }
        BufferedImage copyImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_3BYTE_BGR);
        copyImage.setData(image.getData());
        return copyImage;
    }

    private String getSelectedButtonText(ButtonGroup buttonGroup) {
        for (Enumeration<AbstractButton> buttons = buttonGroup.getElements(); buttons.hasMoreElements();) {
            AbstractButton button = buttons.nextElement();

            if (button.isSelected()) {
                return button.getText();
            }
        }

        return null;
    }

    private int clampColorValue(int val){
        if(val > 255){
            return 255;
        }
        if(val < 0){
            return 0;
        }
        return val;
    }

    private void refreshImageDisplayed(boolean count, boolean duplicate){
        if(duplicate){
            imgZoom = duplicate3BYTEBGR(img);
        }
        ImageIcon icon = new ImageIcon(imgZoom);
        // Adding the ImageIcon to the Label.
        imglabel.setIcon( icon );
        //Aligning the image to the center.
        imglabel.setHorizontalAlignment(JLabel.CENTER);
        //Adding the label to the Scrolling pane.
        jScrollPane.getViewport().add(imglabel);
        // Repainting the scroll pane to update the changes
        jScrollPane.repaint();

        if(count){
            // Recounting colors
            countUniqueColors();
        }
    }

    private int bilinealInterpolation(int colorNW, int colorNE, int colorSW, int colorSE, double a, double b){
        int NWNEr = (int)((1 - a) * ((colorNW >> 16) & 0xff) + a * ((colorNE >> 16) & 0xff));
        int NWNEg = (int)((1 - a) * ((colorNW >> 8) & 0xff) + a * ((colorNE >> 8) & 0xff));
        int NWNEb = (int)((1 - a) * (colorNW & 0xff) + a * (colorNE & 0xff));

        int SWSEr = (int)((1 - a) * ((colorSW >> 16) & 0xff) + a * ((colorSE >> 16) & 0xff));
        int SWSEg = (int)((1 - a) * ((colorSW >> 8) & 0xff) + a * ((colorSE >> 8) & 0xff));
        int SWSEb = (int)((1 - a) * (colorSW & 0xff) + a * (colorSE & 0xff));

        int rTotal = clampColorValue((int)((1 - b) * NWNEr  + b * SWSEr));
        int gTotal = clampColorValue((int)((1 - b) * NWNEg  + b * SWSEg));
        int bTotal = clampColorValue((int)((1 - b) * NWNEb  + b * SWSEb));

        return (255<<24) | (rTotal<<16) | (gTotal<<8) | bTotal;
    }

    private Kernel generateCustomKernel(int w, int h){
        SpinnerNumberModel[] spinnerModels = new SpinnerNumberModel[w*h];
        JSpinner[] kValues = new JSpinner[w*h];
        int[] vals;
        JPanel[] panels = new JPanel[h];
        JPanel pivotPanel = new JPanel();
        Object[] options = {"Aceptar", "Cancelar"};
        Object[] params;
        Kernel k;
        SpinnerNumberModel pivotXModel = new SpinnerNumberModel(w/2, 0, w-1, 1);  // Initial value, min, max, step
        SpinnerNumberModel pivotYModel = new SpinnerNumberModel(h/2, 0, h-1, 1);
        JSpinner pivotX = new JSpinner(pivotXModel);
        JSpinner pivotY = new JSpinner(pivotYModel);
        JLabel labelPivotX = new JLabel("X:");
        JLabel labelPivotY = new JLabel("Y:");

        pivotPanel.add(labelPivotX);
        pivotPanel.add(pivotX);
        pivotPanel.add(labelPivotY);
        pivotPanel.add(pivotY);
        for(int i = 0; i < w * h; i++){
            spinnerModels[i] = new SpinnerNumberModel(1, -100, 100, 1);  // Initial value, min, max, step
            kValues[i] = new JSpinner(spinnerModels[i]);
        }
        for(int i = 0; i < h; i++){
            panels[i] = new JPanel();
            for(int j = 0; j < w ; j++){
                panels[i].add(kValues[i * w + j]);
            }
        }
        params = new Object[]{"Valores del Kernel:",panels,"Coordenadas del Pixel Pivote:", pivotPanel};
        int result = JOptionPane.showOptionDialog(  ScrollPanePanel,
                                                    params,
                                                    "Valores del Kernel Personalizado",
                                                    JOptionPane.YES_NO_OPTION,
                                                    JOptionPane.QUESTION_MESSAGE,
                                                    null,           // Don't use a custom Icon
                                                    options,        // The strings of buttons
                                                    options[0]);    // Default button title
        if ( result == JOptionPane.NO_OPTION){
            return null;
        }
        //Obtaining each spinner value and adding it to a int array.
        vals = new int[w*h];
        for(int i = 0; i < w * h; i++){
            vals[i] = (int)kValues[i].getValue();
        }
        k = new Kernel(vals, w, h, (int)pivotX.getValue(), (int)pivotY.getValue());
        return k;
    }

    private void writeRLEFile(String filename){
        int currentColor;
        int inColor;
        int counter = 0;
        if (img != null){
            try(FileWriter fw = new FileWriter(filename + ".rle")) {
                // Initializing the data with a header according to the format
                switch(format){
                    case 1:
                        fw.write("P1 \n" + width + " " + height + "\n");
                        break;
                    case 2:
                        fw.write("P2 \n" + width + " " + height + "\n");
                        break;
                    case 3:
                        fw.write("P3 \n" + width + " " + height + "\n");
                }
                // This function will create a big array with all the pixel RGB values.
                int[] pixelDataBuffInt = img.getRGB(0, 0, width, height, null, 0, width);
                int maxSize = pixelDataBuffInt.length;

                // Initializing the very first pixel value
                currentColor = pixelDataBuffInt[0];

                for(int i = 0; i < maxSize; i++){
                    // Reading next pixel value
                    inColor = pixelDataBuffInt[i];

                    // If the colors are different write the count to the file and reset
                    if ( inColor != currentColor ){
                        //Writing data to the file according to the format
                        switch(format){
                            case 1: //1 = Black and 0 = White
                                if (((currentColor >> 16) & 0xff) == 0){
                                    fw.write(counter + " 1 ");
                                }else{
                                    fw.write(counter + " 0 ");
                                }
                                break;
                            case 2: // Just the red value.
                                fw.write(counter + " " + ((currentColor >> 16) & 0xff) + " ");
                                break;
                            case 3: // Red, green and blue values together as the same int value.
                                fw.write(counter + " " + currentColor  + " ");   // red, green and blue
                        }

                        currentColor = inColor;
                        counter = 1;
                    }else{
                        counter++;
                    }
                }
                //Writing the last color ocurrence to the file according to the format
                switch(format){
                    case 1: //1 = Black and 0 = White
                        if (((currentColor >> 16) & 0xff) == 0){
                            fw.write(counter + " 1 ");
                        }else{
                            fw.write(counter + " 0 ");
                        }
                        break;
                    case 2: // Just the red value.
                        fw.write(counter + " " + ((currentColor >> 16) & 0xff) + " ");
                        break;
                    case 3: // Red, green and blue values.
                        fw.write(counter + " " + currentColor  + " ");   // red, green and blue
                }

                fw.close();
                Estado.setText("Imagen guardada en: " + filename + ".rle");
            }catch (IOException ex) {
                    Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }

    private void writeNetPBMFile(String filename){
        String ext = "";
        switch(format){
            case 1:
                ext = ".pbm";
                break;
            case 2:
                ext = ".pgm";
                break;
            case 3:
                ext = ".ppm";
        }
        
        if (img != null){
            try(FileWriter fw = new FileWriter(filename + ext)) {
//                long startTime = System.currentTimeMillis();

                // Initializing the data with a header according to the format
                switch(format){
                    case 1:
                        fw.write("P1 \n" + width + " " + height);
                        break;
                    case 2:
                        fw.write("P2 \n" + width + " " + height + " \n" + maxColor);
                        break;
                    case 3:
                        fw.write("P3 \n" + width + " " + height + " \n" + maxColor);
                }
                // This function will create a big array with all the pixel RGB values.
                int[] pixelDataBuffInt = img.getRGB(0, 0, width, height, null, 0, width);

                int maxSize = pixelDataBuffInt.length;
//                long endTime = System.currentTimeMillis();
//                System.out.println("That took " + (endTime - startTime) + " milliseconds");
                for(int i = 0; i < maxSize; i++){
                    // Adding end of line after each row.
                    if (i % width == 0){
                        fw.write("\n");
                    }

                    //Writing data to the file according to the format
                    switch(format){
                        case 1: //1 = Black and 0 = White
                            if (((pixelDataBuffInt[i] >> 16) & 0xff) == 0){
                                fw.write(" 1 ");
                            }else{
                                fw.write(" 0 ");
                            }
                            break;
                        case 2: // Just the red value.
                            fw.write(((pixelDataBuffInt[i] >> 16) & 0xff) + " ");
                            break;
                        case 3: // Red, green and blue values.   
                            fw.write(((pixelDataBuffInt[i] >> 16) & 0xff) + " ");   // red
                            fw.write(((pixelDataBuffInt[i] >> 8) & 0xff) + " ");    // green
                            fw.write((pixelDataBuffInt[i] & 0xff) + " ");           // blue
                    }
                    
                }
//                endTime = System.currentTimeMillis();
//                System.out.println("That took " + (endTime - startTime) + " milliseconds");
                fw.close();
                Estado.setText("Imagen guardada en: " + filename + ext);
            }catch (IOException ex) {
                    Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
    
    private void countUniqueColors(){
        colorsCounter = 0;
        uniqueCols.clear();
        int key;
        if (img != null){
            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                    // Unpacking the color data of each pixel.
                    key = img.getRGB(x,y);
                    
                    // If the color has not been counted.
                    if (uniqueCols.get(key) == null){
                        uniqueCols.put(key, 1);
                        colorsCounter++;
                    } 
                }
            }
        }
    }
    
    private void updateDimensions(){
        if (img != null){
            width = img.getWidth();
            height = img.getHeight();
        } 
    }
		
    private void getBitsPerPixel(){
        if (img != null){
            switch (format) {
                case 3:
                    ColorModel cm = img.getColorModel();
                    bitspp = cm.getPixelSize();
                    break;
                case 2:
                    bitspp = 8;
                    break;
                case 1:
                    bitspp = 1;
                    break;
                default:
                    break;
            }
        }
    }
    
    /*private void getDPI() {
    if (img != null) {
    
    }
    }*/
    
    private void drawHistograms(){
        //Getting dimensions from panels
        Dimension RPanelDim = RedHistogram.getSize();
        int RPanelDimW = RPanelDim.width;
        int RPanelDimH = RPanelDim.height;
        Dimension GrPanelDim = GreenHistogram.getSize();
        int GrPanelDimW = GrPanelDim.width;
        int GrPanelDimH = GrPanelDim.height;
        Dimension BPanelDim = BlueHistogram.getSize();
        int BPanelDimW = BPanelDim.width;
        int BPanelDimH = BPanelDim.height;

        //Creating the general histogram matrix
        Histogram GenHist = new Histogram();
        
        if (bitspp < 24) //If Image is grayscaled or b&w (< 24 bits per pixel), just show a luminosity histogram
        {
            //Operations over histograms
            GenHist.setBins(img, "GRAY");
            GenHist.normalizeHistograms("GRAY");
            GrayBins = GenHist.getGrayHistogram();

            //Graphics creation
            BufferedImage Ghist_base = new BufferedImage(RPanelDimW, RPanelDimH, BufferedImage.TYPE_3BYTE_BGR);
            RojoLabel.setText("Luminosidad");
            grLabel.setIcon(null);
            bLabel.setIcon(null);
            VerdeLabel.setText("-");
            AzulLabel.setText("-");

            //Drawing the graphics
            Graphics2D Ghist_graph = Ghist_base.createGraphics();
            Ghist_graph.setBackground(Color.WHITE);
            Ghist_graph.fillRect(0, 0, RPanelDimW, RPanelDimH);
            Ghist_graph.setColor(Color.BLACK);
            BasicStroke bs = new BasicStroke(1);
            Ghist_graph.setStroke(bs);

            //Baselines
            Ghist_graph.drawLine(4, RPanelDimH-6, 4, 4);
            Ghist_graph.drawLine(4, RPanelDimH-6, RPanelDimW-4, RPanelDimH-6);

            //Histogram lines
            Ghist_graph.setColor(Color.GRAY);
            for (int i = 7; i < 255+8; i++){
                if (GrayBins[i-7] > 0){
                    Ghist_graph.drawLine(i, RPanelDimH-7, i, RPanelDimH-7-GrayBins[i-7]);
                }
            }

            //Setting the icon on its corresponding label
            ImageIcon GrayIcon = new ImageIcon(Ghist_base);
            rLabel.setIcon(GrayIcon);
            RedHistogram.add(rLabel);
            RedHistogram.revalidate();
        }
        else  //If Image is colored (24 bits per pixel), just show a histogram per channel
        {
            //Operations over histograms
            GenHist.setBins(img, "COLOR");
            GenHist.normalizeHistograms("COLOR");
            RedBins = GenHist.getRedHistogram();
            GreenBins = GenHist.getGreenHistogram();
            BlueBins = GenHist.getBlueHistogram();

            //Creating Buffered images for graphics
            BufferedImage Rhist_base = new BufferedImage(RPanelDimW, RPanelDimH, BufferedImage.TYPE_3BYTE_BGR);
            BufferedImage Grhist_base = new BufferedImage(GrPanelDimW, GrPanelDimH, BufferedImage.TYPE_3BYTE_BGR);
            BufferedImage Bhist_base = new BufferedImage(BPanelDimW, BPanelDimH, BufferedImage.TYPE_3BYTE_BGR);

            //Drawing the graphics
            /////////RED
            RojoLabel.setText("Rojo");
            Graphics2D Rhist_graph = Rhist_base.createGraphics();
            Rhist_graph.setBackground(Color.WHITE);
            Rhist_graph.fillRect(0, 0, RPanelDimW, RPanelDimH);
            Rhist_graph.setColor(Color.BLACK);
            BasicStroke bs = new BasicStroke(1);
            Rhist_graph.setStroke(bs);

            //Baselines
            Rhist_graph.drawLine(4, RPanelDimH-6, 4, 4);
            Rhist_graph.drawLine(4, RPanelDimH-6, RPanelDimW-6, RPanelDimH-6);

            //Histogram lines
            Rhist_graph.setColor(Color.RED);
            for (int i = 7; i < 255+8; i++){
                if (RedBins[i-7] > 0){
                    Rhist_graph.drawLine(i, RPanelDimH-7, i, RPanelDimH-7-RedBins[i-7]);
                }
            }

            //Setting the icon on its corresponding label
            ImageIcon RedIcon = new ImageIcon(Rhist_base);
            rLabel.setIcon(RedIcon);
            RedHistogram.add(rLabel);
            RedHistogram.revalidate();

            /////////GREEN
            VerdeLabel.setText("Verde");
            Graphics2D Grhist_graph = Grhist_base.createGraphics();
            Grhist_graph.setBackground(Color.WHITE);
            Grhist_graph.fillRect(0, 0, GrPanelDimW, GrPanelDimH);
            Grhist_graph.setColor(Color.BLACK);
            Grhist_graph.setStroke(bs);

            //Baselines
            Grhist_graph.drawLine(4, GrPanelDimH-6, 4, 4);
            Grhist_graph.drawLine(4, GrPanelDimH-6, GrPanelDimW-6, GrPanelDimH-6);

            //Histogram lines
            Grhist_graph.setColor(Color.GREEN);
            for (int i = 7; i < 255+8; i++){
                if (GreenBins[i-7] > 0){
                    Grhist_graph.drawLine(i, GrPanelDimH-7, i, GrPanelDimH-7-GreenBins[i-7]);
                }
            }

            //Setting the icon on its corresponding label
            ImageIcon GreenIcon = new ImageIcon(Grhist_base);
            grLabel.setIcon(GreenIcon);
            GreenHistogram.add(grLabel);
            GreenHistogram.revalidate();

            /////////BLUE
            AzulLabel.setText("Azul");
            Graphics2D Bhist_graph = Bhist_base.createGraphics();
            Bhist_graph.setBackground(Color.WHITE);
            Bhist_graph.fillRect(0, 0, BPanelDimW, BPanelDimH);
            Bhist_graph.setColor(Color.BLACK);
            Bhist_graph.setStroke(bs);

            //Baselines
            Bhist_graph.drawLine(4, BPanelDimH-6, 4, 4);
            Bhist_graph.drawLine(4, BPanelDimH-6, BPanelDimW-6, BPanelDimH-6);

            //Histogram lines
            Bhist_graph.setColor(Color.BLUE);
            for (int i = 7; i < 255+8; i++){
                if (BlueBins[i-7] > 0){
                    Bhist_graph.drawLine(i, BPanelDimH-7, i, BPanelDimH-7-BlueBins[i-7]);
                }
            }

            //Setting the icon on its corresponding label
            ImageIcon BlueIcon = new ImageIcon(Bhist_base);
            bLabel.setIcon(BlueIcon);
            BlueHistogram.add(bLabel);
            BlueHistogram.revalidate();
        }
    }
		
    private BufferedImage readPBMfromRLE(int width, int height, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int value = 0;
        int row = 0;
        int col = 0;
        int freq = 0;
        while (parser.ttype != StreamTokenizer.TT_EOF){
            try {
                // Reading next token:
                //System.out.println( " 1)current parser value: " + parser.nval );
                parser.nextToken();
                freq = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            if (parser.ttype == StreamTokenizer.TT_EOF){
                //System.out.println( " End of file "  );
                break;
            }
            try {
                // Reading next token:
                parser.nextToken();
                value = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            if (value == 1){
                value = 0;
            }else{
                value = 255;
            }
            for(int i = 0; i<freq; i++ ){
                raster.setSample(col, row, 0, value);
                raster.setSample(col, row, 1, value);
                raster.setSample(col, row, 2, value);
                col++;
                if (col >= width){
                    col = 0;
                    row++;
                }
            }  
        }
        
        return imgTemp;
    }

    private BufferedImage readPGMfromRLE(int width, int height, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int value = 0;
        int row = 0;
        int col = 0;
        int freq = 0;
        //int numTokens = 0;
        while (parser.ttype != StreamTokenizer.TT_EOF){
            try {
                // Reading next token:
                //System.out.println( " 1)current parser value: " + parser.nval );
                parser.nextToken();
                freq = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            if (parser.ttype == StreamTokenizer.TT_EOF){
                //System.out.println( " End of file "  );
                break;
            }
            try {
                // Reading next token:
                parser.nextToken();
                value = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            
            
            for(int i = 0; i<freq; i++ ){
                try{
                    raster.setSample(col, row, 0, value); // R
                    raster.setSample(col, row, 1, value); // G
                    raster.setSample(col, row, 2, value); // B
                    col++;
                    if (col >= width){
                        col = 0;
                        row++;
                    }
                }catch(ArrayIndexOutOfBoundsException e){
                    //System.out.println( "Width: "+ width + "  Height: " + height + "  c: " + col + "  r: " + row + " freq: " + freq + " val: " + value);
                    JOptionPane.showMessageDialog(this, "La imagen está corrompida.");
                    break;
                }
            }  
        }
        return imgTemp;
    }

    private BufferedImage readPPMfromRLE(int width, int height, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int value = 0;
        int row = 0;
        int col = 0;
        int freq = 0;
        while (parser.ttype != StreamTokenizer.TT_EOF){
            try {
                // Reading next token:
                //System.out.println( " 1)current parser value: " + parser.nval );
                parser.nextToken();
                freq = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            if (parser.ttype == StreamTokenizer.TT_EOF){
                //System.out.println( " End of file "  );
                break;
            }
            try {
                // Reading next token:
                parser.nextToken();
                value = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            
            int r = (value >> 16) & 0xff;
            int g = (value >> 8) & 0xff;
            int b = value & 0xff;
            
            for(int i = 0; i<freq; i++ ){
                raster.setSample(col, row, 0, r); // R
                raster.setSample(col, row, 1, g); // G
                raster.setSample(col, row, 2, b); // B
                col++;
                if (col >= width){
                    col = 0;
                    row++;
                }
            }  
        }
        return imgTemp;
    }

    private BufferedImage readPPM(int width, int height, int maxCol, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int value;
        for (int y = 0; y < height; ++y)
            for (int x = 0; x < width; ++x)
                for (int i = 0; i < 3; ++i) {

                    try {
                       // Reading next token:
                       parser.nextToken();
                    } catch (IOException ex) {
                        Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    // If the current token is eof before reading all the width and height of bytes then exit.
                    if (parser.ttype == StreamTokenizer.TT_EOF){
                        JOptionPane.showMessageDialog(this, "La imagen está posiblemente truncada");
                        return null;
                    }
                    // If the current token is not a number then exit.
                    if (parser.ttype != StreamTokenizer.TT_NUMBER){
                        JOptionPane.showMessageDialog(this, "Valor no numerico para la muestra" + i + " del pixel en (" + x + "," + y + ")");
                        return null;
                    }
                    // Rasterizing the data
                    value = ((int)parser.nval * 255)/ maxCol;
                    raster.setSample(x, y, i, value);
                }
        return imgTemp;
    }

    private BufferedImage readPGM(int width, int height,int maxCol, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int pixelValue;
        for (int y = 0; y < height; ++y)
            for (int x = 0; x < width; ++x)
                for (int i = 0; i < 1; ++i) {
                    try {
                       // Reading next token:
                       parser.nextToken();
                    } catch (IOException ex) {
                        Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    // If the current token is eof before reading all the width and height of bytes then exit.
                    if (parser.ttype == StreamTokenizer.TT_EOF){
                        JOptionPane.showMessageDialog(this, "La imagen está posiblemente truncada");
                        return null;
                    }
                    // If the current token is not a number then exit.
                    if (parser.ttype != StreamTokenizer.TT_NUMBER){
                        JOptionPane.showMessageDialog(this, "Valor no numerico para la muestra" + i + " del pixel en (" + x + "," + y + ")");
                        return null;
                    }
                    // Resterizingthe data
                    pixelValue = ((int)parser.nval * 255)/ maxCol;
                    raster.setSample(x, y, 0, pixelValue);// R
                    raster.setSample(x, y, 1, pixelValue);// G
                    raster.setSample(x, y, 2, pixelValue);// B
                }
        return imgTemp;
    }

    private BufferedImage readPBM(int width, int height, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int pixelValue;
        for (int y = 0; y < height; ++y)
            for (int x = 0; x < width; ++x)
                for (int i = 0; i < 1; ++i) {

                    try {
                       // Reading next token:
                       parser.nextToken();
                    } catch (IOException ex) {
                        Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    // If the current token is eof before reading all the width and height of bytes then exit.
                    if (parser.ttype == StreamTokenizer.TT_EOF){
                        JOptionPane.showMessageDialog(this, "La imagen está posiblemente truncada");
                        return null;
                    }
                    // If the current token is not a number then exit.
                    if (parser.ttype != StreamTokenizer.TT_NUMBER){
                        JOptionPane.showMessageDialog(this, "Valor no numerico para la muestra" + i + " del pixel en (" + x + "," + y + ")");
                        return null;
                    }
                    // Rasterizing the data and inverting values because 1 = black and 0 = white in this format.
                    pixelValue = (int)parser.nval ;
                    if (pixelValue == 1){
                        raster.setSample(x, y, 0, 0);
                        raster.setSample(x, y, 1, 0);
                        raster.setSample(x, y, 2, 0);
                    }else{
                        raster.setSample(x, y, 0, 255);
                        raster.setSample(x, y, 1, 255);
                        raster.setSample(x, y, 2, 255);
                    }
                    
                }
        return imgTemp;
    }

    //Function to set parameters of B&W slider
    /**private JSlider getSlider(JOptionPane SliderPane) {
        JSlider sliderAux = new JSlider(0, 255);
        sliderAux.setMajorTickSpacing(50);
        sliderAux.setPaintTicks(true);
        sliderAux.setPaintLabels(true);
        ChangeListener changeListener = new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent changeEvent) {
                JSlider theSlider = (JSlider) changeEvent.getSource();
                if (!theSlider.getValueIsAdjusting()) {
                    SliderPane.setInputValue(new Integer(theSlider.getValue()));
                }
            }
        };
        sliderAux.addChangeListener(changeListener);
        return sliderAux;
    }*/

    // This function provides a ChangeListener based on a JOptionPane that will
    // listen anychanges made in a JOptionsPane
    private ChangeListener createChangeListener(JOptionPane Pane) {
        ChangeListener changeListener = (ChangeEvent changeEvent) -> {
            JSlider theSlider = (JSlider) changeEvent.getSource();
            if (!theSlider.getValueIsAdjusting()) {
                Pane.setInputValue(theSlider.getValue());
            }
        };
        return changeListener;
    }

    private void GuardarBMPActionPerformed(java.awt.event.ActionEvent evt) {                                           
        int returnVal;
        if ( img != null ){
            returnVal = fcSave.showSaveDialog(this); 
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
            return;
        }
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            try {
                //RenderedImage rendImage = bi;
                ImageIO.write(img, "bmp", new File(fcSave.getSelectedFile().getAbsolutePath()+".bmp"));
                Estado.setText("Imagen guardada en: " + fcSave.getSelectedFile().getAbsolutePath()+".bmp");
            } catch ( IOException e) {
                JOptionPane.showMessageDialog(this, "¡ERROR: Ocurrio un error al guardar el archivo!");
            }
        }
    }                                          

    private void AbrirArchivoActionPerformed(java.awt.event.ActionEvent evt) {                                             
        FileInputStream in = null;
        StreamTokenizer parser;
        BufferedReader reader;
        //In response to a button click, the file chooser is displayed
        int returnVal = fcOpen.showOpenDialog(this);

        if (returnVal == JFileChooser.APPROVE_OPTION) {
            // The image variable
            img = null;

            File file = fcOpen.getSelectedFile();
            // Now open the file.
            //JOptionPane.showMessageDialog(this, file.getAbsolutePath());
            // Getting the image extension.
            String path = file.getAbsolutePath();
            String extension = path.substring(path.length() - 3);
            
            if(null != extension){
                // Are we opening a bmp image?
                switch (extension) {
                    case "bmp":
                        try {
                            // Filling BufferedImage with file information
                            img = ImageIO.read(file);
                            // Making note of image properties
                            format = 3;
                            updateDimensions();
                            maxColor = 255;
                            //JOptionPane.showMessageDialog(this, "Imagen tipo: " + types);
                        } catch (IOException e) {
                            // Report exceptions
                            JOptionPane.showMessageDialog(this, "Error al Abrir Imagen!");
                        }
                        break;
                        //log.append("Opening: " + file.getName() + "." + newline);
                    // Are we opening a Netpbm image?
                    case "ppm":
                    case "pgm":
                    case "pbm":
                        // Creating a FileInputStream to be used by the BufferedReader
                        
                        try {
                            in = new FileInputStream( path );
                        } catch (FileNotFoundException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }

                        
                        reader = new BufferedReader(new InputStreamReader(in));
                        parser = new StreamTokenizer(reader);
                        // Filtering out comments from the data
                        parser.commentChar('#');

                        try {
                            // Reading Header(Magic Number):
                           parser.nextToken();
                        } catch (IOException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }

                        // Processing the magic number. (Pending verify this is actually a String)
                        switch(parser.sval){
                            // PBM format
                            case "P1":
                                format = 1;
                                maxColor = 1;
                                break;
                            case "P2":
                                format = 2;
                                break;
                            case "P3":
                                format = 3;
                                break;
                        }

                        //JOptionPane.showMessageDialog(this, format );

                        // Reading image properties from header: Width, Height, max color(optional)
                        try {
                            // Reading Header:
                           parser.nextToken();
                           width = (int)parser.nval;
                           parser.nextToken();
                           height = (int)parser.nval;

                           if (format != 1){
                               parser.nextToken();
                               maxColor = (int)parser.nval;
                           }
                        } catch (IOException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }
                        //JOptionPane.showMessageDialog(this, "W:" + width + " H:" + height + " MaxC:" + maxColor);

                        // Proceeding to read the image data 
                        switch(format){
                            case 1:
                                img = readPBM(width, height, parser);
                                break;
                            case 2:
                                img = readPGM(width, height, maxColor, parser);
                                break;
                            case 3:
                                img = readPPM(width, height, maxColor, parser);
                                break;
                        }
                        maxColor = 255;
                        break;
                    case "rle":
                        try {
                            in = new FileInputStream( path );
                        } catch (FileNotFoundException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }

                        reader = new BufferedReader(new InputStreamReader(in));
                        parser = new StreamTokenizer(reader);

                        try {
                            // Reading Header(Magic Number):
                           parser.nextToken();
                        } catch (IOException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }

                        // Processing the magic number. (Pending verify this is actually a String)
                        switch(parser.sval){
                            // PBM format
                            case "P1":
                                format = 1;
                                maxColor = 1;
                                break;
                            case "P2":
                                format = 2;
                                break;
                            case "P3":
                                format = 3;
                                break;
                        }

                        //JOptionPane.showMessageDialog(this, format );

                        // Reading image properties from header: Width, Height, max color(optional)
                        try {
                            // Reading Header:
                           parser.nextToken();
                           width = (int)parser.nval;
                           parser.nextToken();
                           height = (int)parser.nval;
                        } catch (IOException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }
                        //JOptionPane.showMessageDialog(this, "W:" + width + " H:" + height + " MaxC:" + maxColor);

                        // Proceeding to read the image data 
                        switch(format){
                            case 1:
                                img = readPBMfromRLE(width, height, parser);
                                break;
                            case 2:
                                img = readPGMfromRLE(width, height, parser);
                                break;
                            case 3:
                                img = readPPMfromRLE(width, height, parser);
                                break;
                        }
                        maxColor = 255;
                        break;
                }
                refreshImageDisplayed(true, true);

                // Counting unique colors
                countUniqueColors();
                getBitsPerPixel();
                drawHistograms();

                //Changing Estado Label
                Estado.setText("Abriendo " + file.getAbsolutePath() );
                Colores.setText("Colores únicos: "+colorsCounter);
                Dimensiones.setText("Dimensiones: " + width + "x" + height);
                BPP.setText("Bits por pixel: " + bitspp);
                DPI.setText("Puntos por pulgada (dpi): -"); 

                //Changing Estado Label
                Estado.setText("Abriendo " + file.getAbsolutePath());
            }
        } else {
            // Cancel opening.
            //JOptionPane.showMessageDialog(this, "Opening file canceled.");
            //log.append("Open command cancelled by user." + newline);
        }
    }                                            

    private void NegativoActionPerformed(java.awt.event.ActionEvent evt) {                                         
        // TODO add your handling code here:
        if (img != null){
            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                    // Unpacking the data of each pixel with masks.
                    int p = img.getRGB(x, y);
                    int a = (p >> 24) & 0xff;
                    int r = (p >> 16) & 0xff;
                    int g = (p >> 8) & 0xff;
                    int b = p & 0xff;
                    // Inverting the colors of the pixel per sample.
                    r = 255 - r;
                    g = 255 - g;
                    b = 255 - b;
                    // Packing back the pixel data
                    p = (a<<24) | (r<<16) | (g<<8) | b;
                    img.setRGB(x, y, p);
                }
            }
            refreshImageDisplayed(false, true);
            // Updating status bar.
            Estado.setText("Aplicando Negativo | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }                                        

    private void CompresionRLEActionPerformed(java.awt.event.ActionEvent evt) {                                              
        int returnVal;

        if ( img != null ){
            returnVal = fcSave.showSaveDialog(this);
            if (returnVal == JFileChooser.APPROVE_OPTION) {
                if (format >= 1 && format <= 3)
                    writeRLEFile(fcSave.getSelectedFile().getAbsolutePath());
                else
                   JOptionPane.showMessageDialog(this, "¡ERROR: Error de Formato!");
            }
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }                                             

    private void EscalaDeGrisesActionPerformed(java.awt.event.ActionEvent evt) {                                               
        // TODO add your handling code here:
        if (img != null){
            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                    int avg;
                    // Unpacking the data of each pixel with masks.
                    int p = img.getRGB(x,y);
                    int a = (p>>24)&0xff;
                    int r = (p>>16)&0xff;
                    int g = (p>>8)&0xff;
                    int b = p&0xff;
                    //Calculating average per pixel
                    avg = (r+g+b)/3;
                    // Packing back the pixel data
                    p = (a<<24) | (avg<<16) | (avg<<8) | avg;
                    img.setRGB(x, y, p);
                }
            }
            refreshImageDisplayed(true, true);
            format = 2;
            Estado.setText("Aplicando Escala de Grises | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }                                              

    private void SinCompresionActionPerformed(java.awt.event.ActionEvent evt) {                                              
        int returnVal;

        if ( img != null ){
            returnVal = fcSave.showSaveDialog(this);
            if (returnVal == JFileChooser.APPROVE_OPTION) {
                if (format >= 1 && format <= 3)
                    writeNetPBMFile(fcSave.getSelectedFile().getAbsolutePath());
                else
                   JOptionPane.showMessageDialog(this, "¡ERROR: Error de Formato!"); 
            }
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        } 
    }                                             

    private void BlancoNegroActionPerformed(java.awt.event.ActionEvent evt) {                                            
        if (img != null){
            /** JOptionPane SliderPane = new JOptionPane();
            //Creating a ChangeListener so the changes in the JOptionPane get reflected to the slider.
            thresholdSlider.addChangeListener(createChangeListener( SliderPane ));
            SliderPane.setMessage(new Object[] { "Valor del umbral: ", thresholdSlider });
            SliderPane.setMessageType(JOptionPane.QUESTION_MESSAGE);
            SliderPane.setOptionType(JOptionPane.OK_CANCEL_OPTION);
            JDialog dialog;
            dialog = SliderPane.createDialog(jScrollPane, "Umbral");
            dialog.setVisible(true); */

            Object[] params = {"Valor del umbral: ", thresholdSlider};
            Object[] options = {"Aceptar", "Cancelar"};
            int result = JOptionPane.showOptionDialog(  ScrollPanePanel,
                                                        params,
                                                        "Opciones de Umbralización",
                                                        JOptionPane.YES_NO_OPTION,
                                                        JOptionPane.QUESTION_MESSAGE,
                                                        null,           // Don't use a custom Icon
                                                        options,        // The strings of buttons
                                                        options[0]);    // Default button title
            // Getting threshold value from the slider
            int thr = thresholdSlider.getValue();
            //If the operation was canceled do nothing.
            if (result == JOptionPane.NO_OPTION){
                return;
            }

            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                    int avg;
                    // Unpacking the data of each pixel with masks.
                    int p = img.getRGB(x,y);
                    int a = (p>>24)&0xff;
                    int r = (p>>16)&0xff;
                    int g = (p>>8)&0xff;
                    int b = p&0xff;
                    //Calculating average per pixel
                    avg = (r+g+b)/3;
                    //Sorting average into range according to threshold
                    if (avg < thr){
                        avg = 0;
                    }else{
                        avg = 255;
                    }
                    //Packing back the pixel data
                    p = (a<<24) | (avg<<16) | (avg<<8) | avg;
                    img.setRGB(x, y, p);
                }
            }
            refreshImageDisplayed(true, true);
            format = 1;
            Estado.setText("Aplicando Blanco y Negro | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }                                           

    private void Rotar90CWActionPerformed(java.awt.event.ActionEvent evt) {                                          
        //Declaring an auxiliary image for operations with Width and Height inverted
        if (img != null){
            int imgW = img.getWidth();
            int imgH = img.getHeight();
            //Declaring an auxiliary image for operations with Width and Height inverted
            BufferedImage imgAux = new BufferedImage(imgH, imgW, BufferedImage.TYPE_3BYTE_BGR);
            for (int i = 0; i < imgW; i++){
                for(int j = 0; j < imgH; j++){
                    imgAux.setRGB(imgH - j - 1, i, img.getRGB(i, j));
                }
            }
            img = imgAux;
            updateDimensions();
            refreshImageDisplayed(false, true);
            Estado.setText("Aplicando Rotación 90°CW | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }                                         

    private void Rotar90CCWActionPerformed(java.awt.event.ActionEvent evt) {                                           
        // TODO add your handling code here:
        //Declaring an auxiliary image for operations with Width and Height inverted
        BufferedImage imgAux;
        if (img != null){
            int imgW = img.getWidth();
            int imgH = img.getHeight();
            //assigning imgAux
            imgAux = new BufferedImage(imgH, imgW, img.getType());
            for (int i = 0; i < imgW; i++){
                for(int j = 0; j < imgH; j++){
                    imgAux.setRGB(j, imgW - 1 - i, img.getRGB(i, j));
                }
            }
            img = imgAux;
            updateDimensions();
            refreshImageDisplayed(false, true);
            Estado.setText("Aplicando Rotación 90°CCW | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
        
    }                                          

    private void ReadmeActionPerformed(java.awt.event.ActionEvent evt) {                                       
        // TODO add your handling code here:
        Runtime rt = Runtime.getRuntime();
        String readme = ("README.txt");
        try {
            Process p = rt.exec("notepad "+readme);
        } catch (IOException ex) {
            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
        }
    }                                      

    private void AboutActionPerformed(java.awt.event.ActionEvent evt) {                                      
        // TODO add your handling code here:
        JOptionPane.showMessageDialog(this, "Editor de Imágenes\nRaquel Escalante y Rafael Vasquez\nSemestre 2-2017\nProcesamiento Digital De Imágenes", "Acerca de", JOptionPane.INFORMATION_MESSAGE);
        
    }                                     

    private void SuavizadoGaussianoActionPerformed(java.awt.event.ActionEvent evt) {                                                   
        if (img != null){
            // First, Creating an interface:
            // Radial buttons
            JRadioButton VButton = new JRadioButton("Vertical");
            JRadioButton HButton = new JRadioButton("Horizontal");
            JRadioButton VHButton = new JRadioButton("Ambas");

            ButtonGroup orientationBGroup = new ButtonGroup();
            orientationBGroup.add(VButton);
            orientationBGroup.add(HButton);
            orientationBGroup.add(VHButton);
            VHButton.setSelected(true);         // "Ambas" is the default button.

            JPanel panel = new JPanel();
            panel.add(VButton);
            panel.add(HButton);
            panel.add(VHButton);

            Object[] params = {"Tamaño del kernel: ", kernelSizeSlider, "Orientación:", panel};
            Object[] options = {"Aceptar", "Cancelar"};
            int result = JOptionPane.showOptionDialog(  ScrollPanePanel,
                                                        params,
                                                        "Opciones de Suavizado Gaussiano",
                                                        JOptionPane.YES_NO_OPTION,
                                                        JOptionPane.QUESTION_MESSAGE,
                                                        null,           // Don't use a custom Icon
                                                        options,        // The strings of buttons
                                                        options[0]);    // Default button title

            // Getting the orientation string from the radiobutton group.
            String orientation = getSelectedButtonText(orientationBGroup);

            //If the operation was canceled do nothing.
            if (result == JOptionPane.NO_OPTION){
                return;
            }

            // Parameters for the Gaussian Blur function
            boolean Vert = false;
            boolean Horiz = false;
            switch(orientation){
                case "Horizontal":
                    Horiz = true;
                    break;
                case "Vertical":
                    Vert = true;
                    break;
                default:
                    Vert = true;
                    Horiz = true;
            }

            try{
                // Passing orientation and size to the filter function.
                img = myFilters.GaussianBlur(img, kernelSizeSlider.getValue(), Vert, Horiz);
            }catch(RuntimeException re){
                JOptionPane.showMessageDialog(this, "¡ERROR: Ha ocurrido una excepción:\n" + re.getMessage() );
                return;
            }

            /// Changing the image format since binary becomes grayscale after a blur operation.
            if(format == 1){
                format = 2; // grayscale
                maxColor = 255;
            }
            refreshImageDisplayed(true, true);
            Estado.setText("Aplicando Suavizado Gaussiano | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }                                                  

    private void SuavizadoPromedioActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SuavizadoPromedioActionPerformed
        if (img != null){
            // Preparing and displaying components of the Filter's Options GUI
            int w;
            int h;
            SpinnerNumberModel model1 = new SpinnerNumberModel(3, 1, 7, 1);  // Initial value, min, max, step
            SpinnerNumberModel model2 = new SpinnerNumberModel(3, 1, 7, 1);
            JSpinner spinWidth = new JSpinner(model1);
            JSpinner spinHeight = new JSpinner(model2);
            JLabel labelWidth = new JLabel("Ancho:");
            JLabel labelHeight = new JLabel("Alto:");
            JPanel spinPanel = new JPanel();

            spinPanel.add(labelWidth);
            spinPanel.add(spinWidth);
            spinPanel.add(labelHeight);
            spinPanel.add(spinHeight);

            Object[] params = {spinPanel};
            Object[] options = {"Aceptar", "Cancelar"};
            int result = JOptionPane.showOptionDialog(  ScrollPanePanel,
                                                        params,
                                                        "Opciones de Suavizado Promedio",
                                                        JOptionPane.YES_NO_OPTION,
                                                        JOptionPane.QUESTION_MESSAGE,
                                                        null,           // Don't use a custom Icon
                                                        options,        // The strings of buttons
                                                        options[0]);    // Default button title
            w = (int)spinWidth.getValue();
            h = (int)spinHeight.getValue();
            if ((w == 1 && h == 1) || result == JOptionPane.NO_OPTION){
                // If the kernel is 1x1 the image ends up the same or if the user cancels the action
                // return at once.
                return;
            }
            try{
                // Passing dimensions to the filter function.
                img = myFilters.MeanBlur(img, w, h);
                //AverageBlurController(w, h);
            }catch(RuntimeException re){
                JOptionPane.showMessageDialog(this, "¡ERROR: Ha ocurrido una excepción:\n" + re.getMessage() );
                return;
            }
            // Changing the image format since binary becomes grayscale after a blur operation.
            if(format == 1){
                format = 2; // grayscale
                maxColor = 255;
            }
            refreshImageDisplayed(true, true);
            // Updating status bar.
            Estado.setText("Aplicando Suavizado Promedio | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_SuavizadoPromedioActionPerformed

    private void MedianaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MedianaActionPerformed
        if (img != null){
            // Preparing and displaying components of the Filter's Options GUI
            int w;
            int h;
            SpinnerNumberModel model1 = new SpinnerNumberModel(3, 1, 7, 1);  // Initial value, min, max, step
            SpinnerNumberModel model2 = new SpinnerNumberModel(3, 1, 7, 1);
            JSpinner spinWidth = new JSpinner(model1);
            JSpinner spinHeight = new JSpinner(model2);
            JLabel labelWidth = new JLabel("Ancho:");
            JLabel labelHeight = new JLabel("Alto:");
            JPanel spinPanel = new JPanel();

            spinPanel.add(labelWidth);
            spinPanel.add(spinWidth);
            spinPanel.add(labelHeight);
            spinPanel.add(spinHeight);

            Object[] params = {spinPanel};
            Object[] options = {"Aceptar", "Cancelar"};
            int result = JOptionPane.showOptionDialog(  ScrollPanePanel,
                                                        params,
                                                        "Opciones del Filtro de la Mediana",
                                                        JOptionPane.YES_NO_OPTION,
                                                        JOptionPane.QUESTION_MESSAGE,
                                                        null,           // Don't use a custom Icon
                                                        options,        // The strings of buttons
                                                        options[0]);    // Default button title
            w = (int)spinWidth.getValue();
            h = (int)spinHeight.getValue();
            if ((w == 1 && h == 1) || result == JOptionPane.NO_OPTION){
                // If the kernel is 1x1 the image ends up the same or if the user cancels de action
                // return at once.
                return;
            }
            // Passing dimensions to the filter function.
            img = myFilters.MedianFilter(img, w, h);//   medianFilterController(w, h);
            
            // Changing the image format since binary becomes grayscale after a blur operation.
            if(format == 1){
                format = 2; // grayscale
                maxColor = 255;
            }
            refreshImageDisplayed(true, true);
            // Updating status bar.
            Estado.setText("Aplicando filtro Mediana | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_MedianaActionPerformed

    private void PrewittActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PrewittActionPerformed
        if (img != null){
            // Preparing and displaying components of the Filter's Options GUI
            JRadioButton VButton = new JRadioButton("Vertical |");
            JRadioButton HButton = new JRadioButton("Horizontal -");
            JRadioButton DiagRightButton = new JRadioButton("Diagonal /"); // DiagRight because the upper part is the right one
            JRadioButton DiagLeftButton = new JRadioButton("Diagonal \\");
            JRadioButton AllButton = new JRadioButton("Todas");
            ButtonGroup orientationBGroup = new ButtonGroup();
            JPanel panel1 = new JPanel();
            JPanel panel2 = new JPanel();
            JPanel panel3 = new JPanel();

            orientationBGroup.add(VButton);
            orientationBGroup.add(HButton);
            orientationBGroup.add(DiagRightButton);
            orientationBGroup.add(DiagLeftButton);
            orientationBGroup.add(AllButton);
            AllButton.setSelected(true);         // "Todas" is the default button.
            panel1.add(VButton);
            panel1.add(HButton);
            panel2.add(DiagRightButton);
            panel2.add(DiagLeftButton);
            panel3.add(AllButton);

            Object[] params = {"Orientación:", panel1, panel2, panel3};
            Object[] options = {"Aceptar", "Cancelar"};
            int result = JOptionPane.showOptionDialog(  ScrollPanePanel,
                                                        params,
                                                        "Opciones de Filtro Prewitt",
                                                        JOptionPane.YES_NO_OPTION,
                                                        JOptionPane.QUESTION_MESSAGE,
                                                        null,           // Don't use a custom Icon
                                                        options,        // The strings of buttons
                                                        options[0]);    // Default button title
            // Getting the orientation from the radiobutton group.
            int orientation;
            switch(getSelectedButtonText(orientationBGroup)){
                case "Vertical |":
                    orientation = 1;
                    break;
                case "Horizontal -":
                    orientation = 2;
                    break;
                case "Diagonal /":
                    orientation = 3;
                    break;
                case "Diagonal \\":
                    orientation = 4;
                    break;
                default:
                    orientation = 5;
            }

            //If the operation was canceled do nothing.
            if (result == JOptionPane.NO_OPTION){
                return;
            }
            try{
                // Passing dimensions to the filter function.
                //PrewittController( orientation );
                img = myFilters.Prewitt(img, orientation);
            }catch(RuntimeException re){
                JOptionPane.showMessageDialog(this, "¡ERROR: Ha ocurrido una excepción:\n" + re.getMessage() );
                return;
            }
            // Changing the image format since binary becomes grayscale after a blur operation.
            if(format == 1){
                format = 2; // grayscale
                maxColor = 255;
            }
            refreshImageDisplayed(true, true);
            // Updating status bar.
            Estado.setText("Aplicando filtro de Prewitt | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_PrewittActionPerformed

    private void RobertsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RobertsActionPerformed
        if (img != null){
            try{
                // Passing dimensions to the filter function.
                img = myFilters.Roberts(img);
            }catch(RuntimeException re){
                JOptionPane.showMessageDialog(this, "¡ERROR: Ha ocurrido una excepción:\n" + re.getMessage() );
                return;
            }
            // Changing the image format since binary becomes grayscale after a blur operation.
            if(format == 1){
                format = 2; // grayscale
                maxColor = 255;
            }
            refreshImageDisplayed(true, true);
            // Updating status bar.
            Estado.setText("Aplicando filtro de Roberts | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_RobertsActionPerformed

    private void SobelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SobelActionPerformed
        if (img != null){
            // Preparing and displaying components of the Filter's Options GUI
            JRadioButton VButton = new JRadioButton("Vertical");
            JRadioButton HButton = new JRadioButton("Horizontal");
            JRadioButton AllButton = new JRadioButton("Ambas");
            ButtonGroup orientationBGroup = new ButtonGroup();
            JPanel panel1 = new JPanel();

            orientationBGroup.add(VButton);
            orientationBGroup.add(HButton);
            orientationBGroup.add(AllButton);
            AllButton.setSelected(true);         // "Todas" is the default button.
            panel1.add(VButton);
            panel1.add(HButton);
            panel1.add(AllButton);

            Object[] params = {"Orientación:", panel1};
            Object[] options = {"Aceptar", "Cancelar"};
            int result = JOptionPane.showOptionDialog(  ScrollPanePanel,
                                                        params,
                                                        "Opciones de Filtro Sobel",
                                                        JOptionPane.YES_NO_OPTION,
                                                        JOptionPane.QUESTION_MESSAGE,
                                                        null,           // Don't use a custom Icon
                                                        options,        // The strings of buttons
                                                        options[0]);    // Default button title
            // Getting the orientation from the radiobutton group.
            int orientation;
            switch(getSelectedButtonText(orientationBGroup)){
                case "Vertical":
                    orientation = 1;
                    break;
                case "Horizontal":
                    orientation = 2;
                    break;
                default:
                    orientation = 5;
            }

            //If the operation was canceled do nothing.
            if (result == JOptionPane.NO_OPTION){
                return;
            }
            try{
                // Passing dimensions to the filter function.
                //SobelController( orientation );
                img = myFilters.Sobel(img, orientation);
            }catch(RuntimeException re){
                JOptionPane.showMessageDialog(this, "¡ERROR: Ha ocurrido una excepción:\n" + re.getMessage() );
                return;
            }
            // Changing the image format since binary becomes grayscale after a blur operation.
            if(format == 1){
                format = 2; // grayscale
                maxColor = 255;
            }
            refreshImageDisplayed(true, true);
            // Updating status bar.
            Estado.setText("Aplicando filtro de Sobel | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_SobelActionPerformed

    private void LaplacianoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_LaplacianoActionPerformed
        if (img != null){
            try{
                // Passing dimensions to the filter function.
                img = myFilters.GaussianBlur(img, 3, true, true);
                img = myFilters.Laplacian(img);
                //LaplacianoController();
            }catch(RuntimeException re){
                JOptionPane.showMessageDialog(this, "¡ERROR: Ha ocurrido una excepción:\n" + re.getMessage() );
                return;
            }
            // Changing the image format since binary becomes grayscale after a blur operation.
            if(format == 1){
                format = 2; // grayscale
                maxColor = 255;
            }
            refreshImageDisplayed(true, true);
            // Updating status bar.
            Estado.setText("Aplicando filtro Laplaciano del Gaussiano | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_LaplacianoActionPerformed

    private void PersonalizadoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PersonalizadoActionPerformed
        if (img != null){
            // Preparing and displaying components of the Filter's Options First GUI (Dimensions)
            int w;
            int h;
            SpinnerNumberModel model1 = new SpinnerNumberModel(3, 1, 7, 1);  // Initial value, min, max, step
            SpinnerNumberModel model2 = new SpinnerNumberModel(3, 1, 7, 1);
            JSpinner spinWidth = new JSpinner(model1);
            JSpinner spinHeight = new JSpinner(model2);
            JLabel labelWidth = new JLabel("Ancho:");
            JLabel labelHeight = new JLabel("Alto:");
            JPanel spinPanel = new JPanel();

            spinPanel.add(labelWidth);
            spinPanel.add(spinWidth);
            spinPanel.add(labelHeight);
            spinPanel.add(spinHeight);

            Object[] params = {spinPanel};
            Object[] options = {"Aceptar", "Cancelar"};
            int result = JOptionPane.showOptionDialog(  ScrollPanePanel,
                                                        params,
                                                        "Opciones del Kernel Personalizado",
                                                        JOptionPane.YES_NO_OPTION,
                                                        JOptionPane.QUESTION_MESSAGE,
                                                        null,           // Don't use a custom Icon
                                                        options,        // The strings of buttons
                                                        options[0]);    // Default button title
            w = (int)spinWidth.getValue();
            h = (int)spinHeight.getValue();
            if ((w == 1 && h == 1) || result == JOptionPane.NO_OPTION){
                // If the kernel is 1x1 the image ends up the same or if the user cancels the action
                // return at once.
                return;
            }

            Kernel k = generateCustomKernel(w, h);

            try{
                // Passing dimensions to the filter function.
                //CustomController(k);
                img = myFilters.CustomFilter(img, k);
            }catch(RuntimeException re){
                JOptionPane.showMessageDialog(this, "¡ERROR: Ha ocurrido una excepción:\n" + re.getMessage() );
                return;
            }
            // Changing the image format since binary becomes grayscale after a blur operation.
            if(format == 1){
                format = 2; // grayscale
                maxColor = 255;
            }
            refreshImageDisplayed(true, true);
            // Updating status bar.
            Estado.setText("Aplicando Filtro Personalizado | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_PersonalizadoActionPerformed

    private void ZoomActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ZoomActionPerformed
        if (img != null){
            SpinnerNumberModel model1 = new SpinnerNumberModel(100, 1, 1000, 1);  // Initial value, min, max, step
            JSpinner spinZoomFactor = new JSpinner(model1);
            JLabel labelZoomFactor = new JLabel("Zoom de Imagen original:");
            JLabel labelPercentange = new JLabel(" % (1-1000)");
            JPanel spinPanel = new JPanel();

            spinPanel.add(labelZoomFactor);
            spinPanel.add(spinZoomFactor);
            spinPanel.add(labelPercentange);

            Object[] params = {spinPanel};
            Object[] options = {"Aceptar", "Cancelar"};
            int result = JOptionPane.showOptionDialog(  ScrollPanePanel,
                                                        params,
                                                        "Opción de Zoom",
                                                        JOptionPane.YES_NO_OPTION,
                                                        JOptionPane.QUESTION_MESSAGE,
                                                        null,           // Don't use a custom Icon
                                                        options,        // The strings of buttons
                                                        options[0]);    // Default button title
            if (result == JOptionPane.NO_OPTION){
                return;
            }
            if ((int)spinZoomFactor.getValue() != 100){
                //ZoomController((int)spinZoomFactor.getValue());
                imgZoom = myFilters.Zoom(img, (int)spinZoomFactor.getValue());
                refreshImageDisplayed(false, false);
            }else{
                refreshImageDisplayed(false, true);
            }
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_ZoomActionPerformed

    private void EscalamientoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_EscalamientoActionPerformed
        if (img != null){
            SpinnerNumberModel model1 = new SpinnerNumberModel(100, 1, 1000, 1);  // Initial value, min, max, step
            SpinnerNumberModel model2 = new SpinnerNumberModel(100, 1, 1000, 1);  // Initial value, min, max, step
            JSpinner spinZoomFactorX = new JSpinner(model1);
            JSpinner spinZoomFactorY = new JSpinner(model2);
            JLabel labelZoomFactorX = new JLabel("Ancho:");
            JLabel labelZoomFactorY = new JLabel("  Alto:");
            JLabel labelpctg1 = new JLabel(" %");
            JLabel labelpctg2 = new JLabel(" %");
            JLabel labelComboBox = new JLabel("Interpolación: ");
            JLabel labelValidValues = new JLabel("Valores válidos entre 1 y 1000");
            JPanel spinPanel1 = new JPanel();
            JPanel spinPanel2 = new JPanel();
            String[] scalingTypes = { "Vecino más cercano", "Bilineal" };
            JComboBox scalingTypeList = new JComboBox(scalingTypes);

            labelValidValues.setHorizontalAlignment(JLabel.CENTER);
            spinPanel1.add(labelZoomFactorX);
            spinPanel1.add(spinZoomFactorX);
            spinPanel1.add(labelpctg1);
            spinPanel2.add(labelZoomFactorY);
            spinPanel2.add(spinZoomFactorY);
            spinPanel2.add(labelpctg2);
            scalingTypeList.setSelectedIndex(1);
            Object[] params = {labelValidValues, spinPanel1, spinPanel2,  labelComboBox, scalingTypeList};
            Object[] options = {"Aceptar", "Cancelar"};
            int result = JOptionPane.showOptionDialog(  ScrollPanePanel,
                                                        params,
                                                        "Opciones de Escalamiento",
                                                        JOptionPane.YES_NO_OPTION,
                                                        JOptionPane.QUESTION_MESSAGE,
                                                        null,           // Don't use a custom Icon
                                                        options,        // The strings of buttons
                                                        options[0]);    // Default button title
            if (result == JOptionPane.NO_OPTION){
                return;
            }
            if ((int)spinZoomFactorX.getValue() != 100 || (int)spinZoomFactorY.getValue() != 100){
                img = myFilters.Scale(img, (int)spinZoomFactorX.getValue(), (int)spinZoomFactorY.getValue(), scalingTypeList.getSelectedIndex());
                updateDimensions();
                refreshImageDisplayed(true, true);
            }else{
                refreshImageDisplayed(false, true);
            }
            Estado.setText("Aplicando Escalamiento de " + (int)spinZoomFactorX.getValue() +"% x " + (int)spinZoomFactorY.getValue() + "% | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_EscalamientoActionPerformed

    private void RotacionLibreActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RotacionLibreActionPerformed
        if (img != null){
            JCheckBox cropCB = new JCheckBox("Recortar imagen");
            SpinnerNumberModel model1 = new SpinnerNumberModel(35, 0, 360, 1);  // Initial value, min, max, step
            JSpinner spinDegrees = new JSpinner(model1);
            JLabel labelDegrees = new JLabel("Grados :");
            JLabel labelRotationDirection = new JLabel("Giro en sentido CW");
            JPanel panel1 = new JPanel();
            JLabel labelComboBox = new JLabel("Interpolación: ");
            String[] scalingTypes = { "Vecino más cercano", "Bilineal" };
            JComboBox scalingTypeList = new JComboBox(scalingTypes);

            labelRotationDirection.setHorizontalAlignment(JLabel.CENTER);
            panel1.add(labelDegrees);
            panel1.add(spinDegrees);
            panel1.add(cropCB);
            cropCB.setSelected(true);
            Object[] params = {labelRotationDirection, panel1, labelComboBox, scalingTypeList};
            Object[] options = {"Aceptar", "Cancelar"};
            int result = JOptionPane.showOptionDialog(  ScrollPanePanel,
                                                        params,
                                                        "Opciones de Rotación Libre",
                                                        JOptionPane.YES_NO_OPTION,
                                                        JOptionPane.QUESTION_MESSAGE,
                                                        null,           // Don't use a custom Icon
                                                        options,        // The strings of buttons
                                                        options[0]);    // Default button title
            if (result == JOptionPane.NO_OPTION){
                return;
            }

            if ((int)spinDegrees.getValue() != 0 || (int)spinDegrees.getValue() != 360){
                img = myFilters.FreeRotation(img, (int)spinDegrees.getValue(), cropCB.isSelected(), scalingTypeList.getSelectedIndex());
                //FreeRotationController((int)spinDegrees.getValue(), cropCB.isSelected(), scalingTypeList.getSelectedIndex());
                if(!cropCB.isSelected()){
                    updateDimensions();
                }
                refreshImageDisplayed(true, true);
            }else{
                refreshImageDisplayed(false, true);
            }
            Estado.setText("Aplicando Rotación CW de " + (int)spinDegrees.getValue() +"º | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_RotacionLibreActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ImageEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            new ImageEditor().setVisible(true);
        });
        
        
    }

    // Variables declaration - do not modify                     
    private javax.swing.JMenuItem About;
    private javax.swing.JMenuItem AbrirArchivo;
    private javax.swing.JMenu Ayuda;
    private javax.swing.JLabel AzulLabel;
    private javax.swing.JLabel BPP;
    private javax.swing.JPanel BarraEstado;
    private javax.swing.JPanel BarraEstadoPanel;
    private javax.swing.JMenuItem BlancoNegro;
    private javax.swing.JPanel BlueHistogram;
    private javax.swing.JLabel Colores;
    private javax.swing.JMenu ColorMenu;
    private javax.swing.JMenuItem CompresionRLE;
    private javax.swing.JMenu DetectarBordesMenu;
    private javax.swing.JLabel Dimensiones;
    private javax.swing.JLabel DPI;
    private javax.swing.JMenuItem EscalaDeGrises;
    private javax.swing.JMenuItem Escalamiento;
    private javax.swing.JLabel Estado;
    private javax.swing.JPanel GreenHistogram;
    private javax.swing.JMenuItem GuardarBMP;
    private javax.swing.JMenu GuardarNetpbm;
    private javax.swing.JLabel HistoLabel;
    private javax.swing.JPanel HistoPanel;
    private javax.swing.JPanel ImageInfoPanel;
    private javax.swing.JLabel InfoLabel;
    private javax.swing.JPanel InfoPanel;
    private javax.swing.JMenuItem Laplaciano;
    private javax.swing.JMenuItem Mediana;
    private javax.swing.JMenu MenuArchivo;
    private javax.swing.JMenuBar MenuBar;
    private javax.swing.JMenu MenuEditar;
    private javax.swing.JMenu MenuFiltros;
    private javax.swing.JMenu MenuVer;
    private javax.swing.JMenuItem Negativo;
    private javax.swing.JMenuItem Personalizado;
    private javax.swing.JMenuItem Prewitt;
    private javax.swing.JMenuItem Readme;
    private javax.swing.JPanel RedHistogram;
    private javax.swing.JLabel RojoLabel;
    private javax.swing.JMenuItem Roberts;
    private javax.swing.JMenu Rotacion;
    private javax.swing.JMenuItem RotacionLibre;
    private javax.swing.JMenuItem Rotar90CCW;
    private javax.swing.JMenuItem Rotar90CW;
    private javax.swing.JPanel ScrollPanePanel;
    private javax.swing.JMenuItem SinCompresion;
    private javax.swing.JMenuItem Sobel;
    private javax.swing.JMenuItem SuavizadoGaussiano;
    private javax.swing.JMenu SuavizadoMenu;
    private javax.swing.JMenuItem SuavizadoPromedio;
    private javax.swing.JLabel VerdeLabel;
    private javax.swing.JMenuItem Zoom;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JMenuItem jMenuItem3;
    private javax.swing.JScrollPane jScrollPane;
    private javax.swing.JPopupMenu.Separator jSeparator1;
    private javax.swing.JPopupMenu.Separator jSeparator2;
    // End of variables declaration                   
  }