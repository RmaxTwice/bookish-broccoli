
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.WritableRaster;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JSlider;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.filechooser.FileNameExtensionFilter;
import java.lang.Object;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Raquel Escalante, Rafael Vasquez
 */
public class ImageEditor extends javax.swing.JFrame {
    
    // Creating a JLabel to display image.
    private JLabel imglabel;
    // Creating a file chooser to open files with
    private JFileChooser fcOpen;
    // Creating a file chooser to save files with
    private JFileChooser fcSave;
    // Properties of the Image
    private int format;
    private int width;
    private int height;
    private int maxColor;
    private BufferedImage img = null;
    // Hashmap and counter used to count unique colors
    private HashMap<Integer, Integer> uniqueCols;
    private int colorsCounter;
    private JSlider slider;
    
    
    /**
     * Creates new form ImageEditor
     */
    public ImageEditor() {
        initComponents();
        
        imglabel = new JLabel();
        fcOpen = new JFileChooser();
        fcSave = new JFileChooser();
        // Creating file filters for the file choosers
        FileNameExtensionFilter imagesFilter = new FileNameExtensionFilter("Imágenes: *.bmp, *.pbm, *.pgm, *.ppm", "bmp", "pbm", "pgm", "ppm");
        FileNameExtensionFilter savingFilter = new FileNameExtensionFilter("Imágenes RLE: *.rle", "rle");
        fcOpen.addChoosableFileFilter(imagesFilter);
        fcOpen.addChoosableFileFilter(savingFilter);
        fcOpen.setFileFilter(imagesFilter);
        
//        fcSave.addChoosableFileFilter(savingFilter);
//        fcSave.setFileFilter(savingFilter);
        
        uniqueCols = new HashMap<>();
        colorsCounter = 0;
        slider = new JSlider(0, 255);
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jMenu1 = new javax.swing.JMenu();
        ScrollPanePanel = new javax.swing.JPanel();
        jScrollPane = new javax.swing.JScrollPane();
        BarraEstadoPanel = new javax.swing.JPanel();
        BarraEstado = new javax.swing.JPanel();
        Estado = new javax.swing.JLabel();
        MenuBar = new javax.swing.JMenuBar();
        MenuArchivo = new javax.swing.JMenu();
        AbrirArchivo = new javax.swing.JMenuItem();
        GuardarBMP = new javax.swing.JMenuItem();
        GuardarNetpbm = new javax.swing.JMenu();
        SinCompresion = new javax.swing.JMenuItem();
        CompresionRLE = new javax.swing.JMenuItem();
        MenuEditar = new javax.swing.JMenu();
        Negativo = new javax.swing.JMenuItem();
        BlancoNegro = new javax.swing.JMenuItem();
        EscalaDeGrises = new javax.swing.JMenuItem();
        Rotacion = new javax.swing.JMenu();
        Rotar90CW = new javax.swing.JMenuItem();
        Rotar90CCW = new javax.swing.JMenuItem();
        Ayuda = new javax.swing.JMenu();
        Readme = new javax.swing.JMenuItem();
        About = new javax.swing.JMenuItem();

        jMenu1.setText("jMenu1");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Editor de Imagenes | by Raquel Escalante & Rafael Vasquez");
        setBounds(new java.awt.Rectangle(0, 0, 800, 600));
        setMaximumSize(getMaximumSize());

        jScrollPane.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        jScrollPane.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        jScrollPane.setDoubleBuffered(true);
        jScrollPane.setPreferredSize(new java.awt.Dimension(1011, 1));

        javax.swing.GroupLayout ScrollPanePanelLayout = new javax.swing.GroupLayout(ScrollPanePanel);
        ScrollPanePanel.setLayout(ScrollPanePanelLayout);
        ScrollPanePanelLayout.setHorizontalGroup(
            ScrollPanePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(ScrollPanePanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 988, Short.MAX_VALUE)
                .addContainerGap())
        );
        ScrollPanePanelLayout.setVerticalGroup(
            ScrollPanePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(ScrollPanePanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 571, Short.MAX_VALUE)
                .addContainerGap())
        );

        BarraEstado.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        Estado.setText("Bienvenido");

        javax.swing.GroupLayout BarraEstadoLayout = new javax.swing.GroupLayout(BarraEstado);
        BarraEstado.setLayout(BarraEstadoLayout);
        BarraEstadoLayout.setHorizontalGroup(
            BarraEstadoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(BarraEstadoLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(Estado)
                .addContainerGap(928, Short.MAX_VALUE))
        );
        BarraEstadoLayout.setVerticalGroup(
            BarraEstadoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(BarraEstadoLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(Estado)
                .addContainerGap())
        );

        javax.swing.GroupLayout BarraEstadoPanelLayout = new javax.swing.GroupLayout(BarraEstadoPanel);
        BarraEstadoPanel.setLayout(BarraEstadoPanelLayout);
        BarraEstadoPanelLayout.setHorizontalGroup(
            BarraEstadoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(BarraEstadoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(BarraEstado, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        BarraEstadoPanelLayout.setVerticalGroup(
            BarraEstadoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(BarraEstadoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(BarraEstado, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        MenuArchivo.setText("Archivo");

        AbrirArchivo.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        AbrirArchivo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Open16.gif"))); // NOI18N
        AbrirArchivo.setText("Abrir Imagen...");
        AbrirArchivo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AbrirArchivoActionPerformed(evt);
            }
        });
        MenuArchivo.add(AbrirArchivo);

        GuardarBMP.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        GuardarBMP.setIcon(new javax.swing.ImageIcon(getClass().getResource("/SaveBMP.gif"))); // NOI18N
        GuardarBMP.setText("Guardar BMP");
        GuardarBMP.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                GuardarBMPActionPerformed(evt);
            }
        });
        MenuArchivo.add(GuardarBMP);

        GuardarNetpbm.setText("Guardar Netpbm");

        SinCompresion.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.SHIFT_MASK));
        SinCompresion.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Save16.gif"))); // NOI18N
        SinCompresion.setText("Sin Compresión");
        SinCompresion.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SinCompresionActionPerformed(evt);
            }
        });
        GuardarNetpbm.add(SinCompresion);

        CompresionRLE.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        CompresionRLE.setIcon(new javax.swing.ImageIcon(getClass().getResource("/SaveRLE.gif"))); // NOI18N
        CompresionRLE.setText("Con compresión RLE");
        CompresionRLE.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CompresionRLEActionPerformed(evt);
            }
        });
        GuardarNetpbm.add(CompresionRLE);

        MenuArchivo.add(GuardarNetpbm);

        MenuBar.add(MenuArchivo);

        MenuEditar.setText("Editar");

        Negativo.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_N, java.awt.event.InputEvent.CTRL_MASK));
        Negativo.setText("Negativo");
        Negativo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                NegativoActionPerformed(evt);
            }
        });
        MenuEditar.add(Negativo);

        BlancoNegro.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_B, java.awt.event.InputEvent.CTRL_MASK));
        BlancoNegro.setText("Blanco y Negro");
        BlancoNegro.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                BlancoNegroActionPerformed(evt);
            }
        });
        MenuEditar.add(BlancoNegro);

        EscalaDeGrises.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_G, java.awt.event.InputEvent.CTRL_MASK));
        EscalaDeGrises.setText("Escala de Grises");
        EscalaDeGrises.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                EscalaDeGrisesActionPerformed(evt);
            }
        });
        MenuEditar.add(EscalaDeGrises);

        Rotacion.setText("Rotación");

        Rotar90CW.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_RIGHT, java.awt.event.InputEvent.CTRL_MASK));
        Rotar90CW.setText("90° CW");
        Rotar90CW.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Rotar90CWActionPerformed(evt);
            }
        });
        Rotacion.add(Rotar90CW);

        Rotar90CCW.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_LEFT, java.awt.event.InputEvent.CTRL_MASK));
        Rotar90CCW.setText("90° CCW");
        Rotar90CCW.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Rotar90CCWActionPerformed(evt);
            }
        });
        Rotacion.add(Rotar90CCW);

        MenuEditar.add(Rotacion);

        MenuBar.add(MenuEditar);

        Ayuda.setText("Ayuda");

        Readme.setText("Léeme");
        Readme.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ReadmeActionPerformed(evt);
            }
        });
        Ayuda.add(Readme);

        About.setText("Acerca De...");
        About.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AboutActionPerformed(evt);
            }
        });
        Ayuda.add(About);

        MenuBar.add(Ayuda);

        setJMenuBar(MenuBar);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(ScrollPanePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
            .addComponent(BarraEstadoPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(ScrollPanePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(BarraEstadoPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    
    /**
     * 
     * @param evt 
     */
    
    private String generateRLECompressionFromPBM(){
        // 1 = Black and 0 = White
        // Initializing the data with width and height
        String data = "";
        int currentColor = -1;
        int inColor;
        int counter = 0;
        int r = 0;
        if (img != null){
            data = "P1 \n" + width + " " + height + " \n";
            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                    if(x == 0 && y == 0){
                        currentColor = img.getRGB(x,y);
                    }
                    // Unpacking the color of each pixel.
                    inColor = img.getRGB(x,y);
                    r = (currentColor >> 16) & 0xff;
                    // Comparing read color "inColor" with current color:
                    if ( inColor != currentColor ){
                        if (r != 0){
                            data = data + counter + " 0 ";
                        }else{
                            data = data + counter + " 1 ";
                        }
                        currentColor = inColor;
                        counter = 1;
                    }else{
                        counter++;
                    }
                }
            }
            // Filling the last color ocurrence
            if (r != 0){
                data = data + counter + " 0 ";
            }else{
                data = data + counter + " 1 ";
            }
        }

        return data;
    }
    
    private String generateRLECompressionFromPGM(){
        // Initializing the data with width and height
        String data = "";
        int currentColor = -1;
        int inColor;
        int counter = 0;
        int r = 0;
        if (img != null){
            data = "P2 \n" + width + " " + height + " \n";
            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                    if(x == 0 && y == 0){
                        currentColor = img.getRGB(x,y);
                    }
                    // Unpacking the color of each pixel.
                    inColor = img.getRGB(x,y);
                    
                    r = (currentColor >> 16) & 0xff;
                    int g = (currentColor >> 8) & 0xff;
                    int b = currentColor & 0xff;
                    // Comparing read color "inColor" with current color:
                    if ( inColor != currentColor ){
                        // Writing intances in a row and the color separated by a space
                        data = data + counter + " " + r + " ";
                        currentColor = inColor;
                        counter = 1;
                    }else{
                        counter++;
                    }
                }
            }
            // Filling the last color ocurrence
            data = data + counter + " " + r + " ";
            
        }
        return data;
    }
    
    private String generateRLECompressionFromPPM(){
        // Initializing the data with width and height
        String data = "";
        int currentColor = -1;
        int inColor;
        int counter = 0;
        if (img != null){
            data = "P3 \n" + width + " " + height + " \n";
            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                    if(x == 0 && y == 0){
                        currentColor = img.getRGB(x,y);
                    }
                    // Unpacking the color of each pixel.
                    inColor = img.getRGB(x,y);
                    //r = (currentColor >> 16) & 0xff;
                    // Comparing read color "inColor" with current color:
                    if ( inColor != currentColor ){
                        // Writing intances in a row and the color separated by a space
                        data = data + counter + " " + currentColor + " ";
                        currentColor = inColor;
                        counter = 1;
                    }else{
                        counter++;
                    }
                }
            }
        }
        return data;
    }
     
    private void generatePBM( String filename ){
        // 1 = Black and 0 = White
        if (img != null){
            
            try(FileWriter fw = new FileWriter(filename)) {
                long startTime = System.currentTimeMillis();
                // Initializing the data with magic number, width and height
                fw.write("P1 \n" + width + " " + height);
                
                // This function will create a big array with all the pixel RGB values.
                int[] pixelDataBuffInt = img.getRGB(0, 0, width, height, null, 0, width); 
            
                int maxSize = pixelDataBuffInt.length;
                long endTime = System.currentTimeMillis();
                System.out.println("That took " + (endTime - startTime) + " milliseconds");
                for(int i = 0; i < maxSize; i++){
                    // Adding end of line after each row.
                    if (i % width == 0){
                        fw.write("\n");
                    }
                    //Adding data to string.
                    if (((pixelDataBuffInt[i] >> 16) & 0xff) == 0){
                        fw.write(" 1 ");
                    }else{
                        fw.write(" 0 ");  
                    }
                } 
                endTime = System.currentTimeMillis();
                System.out.println("That took " + (endTime - startTime) + " milliseconds");
                fw.close();
            }catch (IOException ex) {
                    Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
    
    private String generatePGM(){
        // Initializing the data with width and height
        String data = "";
        int inColor;
        int r;
        if (img != null){
            data = "P2 \n" + width + " " + height + " \n" + maxColor + "\n";
            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                    // Unpacking the color of each pixel, just red sample is enough
                    inColor = img.getRGB(x,y);
                    r = (inColor >> 16) & 0xff;
                    
                    // Concatenating the current pixel's color value with previous data:
                    data = data + r + " ";

                }
                // Adding end of line after each row.
                data = data + "\n";
            }
        }
        return data;
    }
    
    private String generatePPM(){
        // Initializing the data with width and height
        
        String data = "";
        int inColor;
        int r, g, b;
        if (img != null){
            data = "P2 \n" + width + " " + height + " \n" + maxColor + "\n";
            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                    // Unpacking the color of each pixel into each sample value.
                    inColor = img.getRGB(x,y);
                    r = (inColor >> 16) & 0xff;
                    g = (inColor >> 8) & 0xff;
                    b = inColor & 0xff;
                    // Concatenating the current pixel's color value with previous data:
                    data = data + r + " " + g + " " + b + " ";

                }
                // Adding end of line after each row.
                data = data + "\n";
            }
        }
        return data;
    }
    
    private void countUniqueColors(){
        int key;
        if (img != null){
            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                    // Unpacking the color data of each pixel.
                    key = img.getRGB(x,y);
                    
                    // If the color has not been counted.
                    if (uniqueCols.get(key) == null){
                        uniqueCols.put(key, 1);
                        colorsCounter++;
                    } 
                }
            }
        }
    }
    
    private BufferedImage readPBMfromRLE(int width, int height, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int value = 0;
        int row = 0;
        int col = 0;
        int freq = 0;
        while (parser.ttype != StreamTokenizer.TT_EOF){
            try {
                // Reading next token:
                //System.out.println( " 1)current parser value: " + parser.nval );
                parser.nextToken();
                freq = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            if (parser.ttype == StreamTokenizer.TT_EOF){
                //System.out.println( " End of file "  );
                break;
            }
            try {
                // Reading next token:
                parser.nextToken();
                value = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            if (value == 1){
                value = 0;
            }else{
                value = 255;
            }
            for(int i = 0; i<freq; i++ ){
                raster.setSample(col, row, 0, value);
                raster.setSample(col, row, 1, value);
                raster.setSample(col, row, 2, value);
                col++;
                if (col >= width){
                    col = 0;
                    row++;
                }
            }  
        }
        
        return imgTemp;
    }
    
    private BufferedImage readPGMfromRLE(int width, int height, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int value = 0;
        int row = 0;
        int col = 0;
        int freq = 0;
        int numTokens = 0;
        while (parser.ttype != StreamTokenizer.TT_EOF){
            try {
                // Reading next token:
                //System.out.println( " 1)current parser value: " + parser.nval );
                parser.nextToken();
                freq = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            if (parser.ttype == StreamTokenizer.TT_EOF){
                //System.out.println( " End of file "  );
                break;
            }
            try {
                // Reading next token:
                parser.nextToken();
                value = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            
            
            for(int i = 0; i<freq; i++ ){
                try{
                    raster.setSample(col, row, 0, value); // R
                    raster.setSample(col, row, 1, value); // G
                    raster.setSample(col, row, 2, value); // B
                    col++;
                    if (col >= width){
                        col = 0;
                        row++;
                    }
                }catch(ArrayIndexOutOfBoundsException e){
                    System.out.println( "Width: "+ width + "  Height: " + height + "  c: " + col + "  r: " + row + " freq: " + freq + " val: " + value);
                }
            }  
        }
        return imgTemp;
    }
    
    private BufferedImage readPPMfromRLE(int width, int height, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int value = 0;
        int row = 0;
        int col = 0;
        int freq = 0;
        while (parser.ttype != StreamTokenizer.TT_EOF){
            try {
                // Reading next token:
                //System.out.println( " 1)current parser value: " + parser.nval );
                parser.nextToken();
                freq = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            if (parser.ttype == StreamTokenizer.TT_EOF){
                //System.out.println( " End of file "  );
                break;
            }
            try {
                // Reading next token:
                parser.nextToken();
                value = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            
            int r = (value >> 16) & 0xff;
            int g = (value >> 8) & 0xff;
            int b = value & 0xff;
            
            for(int i = 0; i<freq; i++ ){
                raster.setSample(col, row, 0, r); // R
                raster.setSample(col, row, 1, g); // G
                raster.setSample(col, row, 2, b); // B
                col++;
                if (col >= width){
                    col = 0;
                    row++;
                }
            }  
        }
        return imgTemp;
    }
    
    private BufferedImage readPPM(int width, int height, int maxCol, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int value;
        for (int y = 0; y < height; ++y)
            for (int x = 0; x < width; ++x)
                for (int i = 0; i < 3; ++i) {

                    try {
                       // Reading next token:
                       parser.nextToken();
                    } catch (IOException ex) {
                        Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    // If the current token is eof before reading all the width and height of bytes then exit.
                    if (parser.ttype == StreamTokenizer.TT_EOF){
                        JOptionPane.showMessageDialog(this, "La imagen está posiblemente truncada");
                        return null;
                    }
                    // If the current token is not a number then exit.
                    if (parser.ttype != StreamTokenizer.TT_NUMBER){
                        JOptionPane.showMessageDialog(this, "Valor no numerico para la muestra" + i + " del pixel en (" + x + "," + y + ")");
                        return null;
                    }
                    // Rasterizing the data
                    value = ((int)parser.nval * 255)/ maxCol;
                    raster.setSample(x, y, i, value);
                }
        return imgTemp;
    }

    private BufferedImage readPGM(int width, int height,int maxCol, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int pixelValue;
        for (int y = 0; y < height; ++y)
            for (int x = 0; x < width; ++x)
                for (int i = 0; i < 1; ++i) {
                    try {
                       // Reading next token:
                       parser.nextToken();
                    } catch (IOException ex) {
                        Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    // If the current token is eof before reading all the width and height of bytes then exit.
                    if (parser.ttype == StreamTokenizer.TT_EOF){
                        JOptionPane.showMessageDialog(this, "La imagen está posiblemente truncada");
                        return null;
                    }
                    // If the current token is not a number then exit.
                    if (parser.ttype != StreamTokenizer.TT_NUMBER){
                        JOptionPane.showMessageDialog(this, "Valor no numerico para la muestra" + i + " del pixel en (" + x + "," + y + ")");
                        return null;
                    }
                    // Resterizingthe data
                    pixelValue = ((int)parser.nval * 255)/ maxCol;
                    raster.setSample(x, y, 0, pixelValue);// R
                    raster.setSample(x, y, 1, pixelValue);// G
                    raster.setSample(x, y, 2, pixelValue);// B
                }
        return imgTemp;
    }
        
    private BufferedImage readPBM(int width, int height, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int pixelValue;
        for (int y = 0; y < height; ++y)
            for (int x = 0; x < width; ++x)
                for (int i = 0; i < 1; ++i) {

                    try {
                       // Reading next token:
                       parser.nextToken();
                    } catch (IOException ex) {
                        Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    // If the current token is eof before reading all the width and height of bytes then exit.
                    if (parser.ttype == StreamTokenizer.TT_EOF){
                        JOptionPane.showMessageDialog(this, "La imagen está posiblemente truncada");
                        return null;
                    }
                    // If the current token is not a number then exit.
                    if (parser.ttype != StreamTokenizer.TT_NUMBER){
                        JOptionPane.showMessageDialog(this, "Valor no numerico para la muestra" + i + " del pixel en (" + x + "," + y + ")");
                        return null;
                    }
                    // Rasterizing the data and inverting values because 1 = black and 0 = white in this format.
                    pixelValue = (int)parser.nval ;
                    if (pixelValue == 1){
                        raster.setSample(x, y, 0, 0);
                        raster.setSample(x, y, 1, 0);
                        raster.setSample(x, y, 2, 0);
                    }else{
                        raster.setSample(x, y, 0, 255);
                        raster.setSample(x, y, 1, 255);
                        raster.setSample(x, y, 2, 255);
                    }
                    
                }
        return imgTemp;
    }
    
    //Function to set parameters of B&W slider
    private JSlider getSlider(JOptionPane SliderPane) {
        JSlider slider = new JSlider(0, 255);
        slider.setMajorTickSpacing(50);
        slider.setPaintTicks(true);
        slider.setPaintLabels(true);
        ChangeListener changeListener = new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent changeEvent) {
                JSlider theSlider = (JSlider) changeEvent.getSource();
                if (!theSlider.getValueIsAdjusting()) {
                    SliderPane.setInputValue(new Integer(theSlider.getValue()));
                }
            }
        };
        slider.addChangeListener(changeListener);
        return slider;
    }
    
    private void GuardarBMPActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_GuardarBMPActionPerformed
        // TODO add your handling code here:
        int returnVal;
        
        if ( img != null ){
            returnVal = fcSave.showSaveDialog(this); 
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
            return;
        }
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            
            try {
                //RenderedImage rendImage = bi;
                ImageIO.write(img, "bmp", new File(fcSave.getSelectedFile().getAbsolutePath()+".bmp"));
            } catch ( IOException e) {
                e.printStackTrace();
            }
        }
        
    }//GEN-LAST:event_GuardarBMPActionPerformed

    private void AbrirArchivoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AbrirArchivoActionPerformed
        // TODO add your handling code here:
        // The image variable
        img = null;
        // Resetting unique colors container for new image.
        uniqueCols.clear();
        colorsCounter = 0;
        
        FileInputStream in = null;
        StreamTokenizer parser;
        BufferedReader reader;
        //In response to a button click, the file chooser is displayed
        int returnVal = fcOpen.showOpenDialog(this);
        
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File file = fcOpen.getSelectedFile();
            // Now open the file.
            //JOptionPane.showMessageDialog(this, file.getAbsolutePath());
            // Getting the image extension.
            String path = file.getAbsolutePath();
            String extension = path.substring(path.length() - 3);
            
            if(null != extension){
                // Are we opening a bmp image?
                switch (extension) {
                    case "bmp":
                        try {
                            // Filling BufferedImage with file information
                            img = ImageIO.read(file);
                            // Making note of image properties
                            format = 3;
                            width = img.getWidth();
                            height = img.getHeight();
                            maxColor = 255;
                            //JOptionPane.showMessageDialog(this, "Imagen tipo: " + types);
                        } catch (IOException e) {
                            // Report exceptions
                            JOptionPane.showMessageDialog(this, "Error al Abrir Imagen!");
                        }
                        break;
                        //log.append("Opening: " + file.getName() + "." + newline);
                    // Are we opening a Netpbm image?
                    case "ppm":
                    case "pgm":
                    case "pbm":
                        // Creating a FileInputStream to be used by the BufferedReader
                        
                        try {
                            in = new FileInputStream( path );
                        } catch (FileNotFoundException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }

                        
                        reader = new BufferedReader(new InputStreamReader(in));
                        parser = new StreamTokenizer(reader);
                        // Filtering out comments from the data
                        parser.commentChar('#');

                        try {
                            // Reading Header(Magic Number):
                           parser.nextToken();
                        } catch (IOException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }

                        // Processing the magic number. (Pending verify this is actually a String)
                        switch(parser.sval){
                            // PBM format
                            case "P1":
                                format = 1;
                                maxColor = 1;
                                break;
                            case "P2":
                                format = 2;
                                break;
                            case "P3":
                                format = 3;
                                break;
                        }

                        //JOptionPane.showMessageDialog(this, format );

                        // Reading image properties from header: Width, Height, max color(optional)
                        try {
                            // Reading Header:
                           parser.nextToken();
                           width = (int)parser.nval;
                           parser.nextToken();
                           height = (int)parser.nval;

                           if (format != 1){
                               parser.nextToken();
                               maxColor = (int)parser.nval;
                           }
                        } catch (IOException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }
                        //JOptionPane.showMessageDialog(this, "W:" + width + " H:" + height + " MaxC:" + maxColor);

                        // Proceeding to read the image data 
                        switch(format){
                            case 1:
                                img = readPBM(width, height, parser);
                                break;
                            case 2:
                                img = readPGM(width, height, maxColor, parser);
                                break;
                            case 3:
                                img = readPPM(width, height, maxColor, parser);
                                break;
                        }
                        break;
                    case "rle":
                        try {
                            in = new FileInputStream( path );
                        } catch (FileNotFoundException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }

                        reader = new BufferedReader(new InputStreamReader(in));
                        parser = new StreamTokenizer(reader);

                        try {
                            // Reading Header(Magic Number):
                           parser.nextToken();
                        } catch (IOException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }

                        // Processing the magic number. (Pending verify this is actually a String)
                        switch(parser.sval){
                            // PBM format
                            case "P1":
                                format = 1;
                                maxColor = 1;
                                break;
                            case "P2":
                                format = 2;
                                break;
                            case "P3":
                                format = 3;
                                break;
                        }

                        //JOptionPane.showMessageDialog(this, format );

                        // Reading image properties from header: Width, Height, max color(optional)
                        try {
                            // Reading Header:
                           parser.nextToken();
                           width = (int)parser.nval;
                           parser.nextToken();
                           height = (int)parser.nval;
                        } catch (IOException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }
                        //JOptionPane.showMessageDialog(this, "W:" + width + " H:" + height + " MaxC:" + maxColor);

                        // Proceeding to read the image data 
                        switch(format){
                            case 1:
                                img = readPBMfromRLE(width, height, parser);
                                break;
                            case 2:
                                img = readPGMfromRLE(width, height, parser);
                                break;
                            case 3:
                                img = readPPMfromRLE(width, height, parser);
                                break;
                        }
                        break;
                }
                
                ImageIcon icon = new ImageIcon(img);
                // Adding the ImageIcon to the Label.
                imglabel.setIcon( icon );
                //Aligning the image to the center.
                imglabel.setHorizontalAlignment(JLabel.CENTER);
                //Adding the label to the Scrolling pane.
                jScrollPane.getViewport().add(imglabel);

                // Counting unique colors
                countUniqueColors();
                
                //Changing Estado Label
                Estado.setText("Abriendo " + file.getAbsolutePath() + " | Colores Únicos en imagen: " + colorsCounter);
            }
        } else {
            // Cancel opening.
            //JOptionPane.showMessageDialog(this, "Opening file canceled.");
            //log.append("Open command cancelled by user." + newline);
        }
    }//GEN-LAST:event_AbrirArchivoActionPerformed

    private void NegativoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_NegativoActionPerformed
        // TODO add your handling code here:
        if (img != null){
            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                
                    // Unpacking the data of each pixel with masks.
                    int p = img.getRGB(x, y);
                    int a = (p >> 24) & 0xff;
                    int r = (p >> 16) & 0xff;
                    int g = (p >> 8) & 0xff;
                    int b = p & 0xff;
                    
                    // Inverting the colors of the pixel per sample.
                    r = 255 - r;
                    g = 255 - g;
                    b = 255 - b;
                    
                    // Packing back the pixel data
                    p = (a<<24) | (r<<16) | (g<<8) | b;
                    img.setRGB(x, y, p);
                    
                    // Repainting the scroll pane to update the changes
                    jScrollPane.repaint();
                    // Updating status bar.
                    Estado.setText("Aplicando Negativo | Colores Únicos en imagen: " + colorsCounter);
                }
            }    
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_NegativoActionPerformed

    private void CompresionRLEActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CompresionRLEActionPerformed
        // TODO add your handling code here:
        String fileData = "";
        int returnVal;
        
        if ( img != null ){
            returnVal = fcSave.showSaveDialog(this);
            Estado.setText("Guardando...");
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
            return;
        }
        
        switch(format){
            case 1:
                fileData = generateRLECompressionFromPBM();
                break;
            case 2:
                fileData = generateRLECompressionFromPGM();
                break;
            case 3:
                fileData = generateRLECompressionFromPPM();
                break;
            default:
                JOptionPane.showMessageDialog(this, "La imagen original no es Netpbm, no se puede comprimir mediante RLE.");
                break;
        }
        
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            // Writing to file with extension .rle with name and path indicated by file chooser
            try(FileWriter fw = new FileWriter(fcSave.getSelectedFile()+".rle")) {
                fw.write(fileData);
                fw.close();
            }catch (IOException ex) {
                    Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            Estado.setText("Imagen RLE guardada en: " + fcSave.getSelectedFile()+".rle");
        }
        
    }//GEN-LAST:event_CompresionRLEActionPerformed

    private void EscalaDeGrisesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_EscalaDeGrisesActionPerformed
        // TODO add your handling code here:
        if (img != null){
            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                    int avg;
                    // Unpacking the data of each pixel with masks.
                    int p = img.getRGB(x,y);
                    int a = (p>>24)&0xff;
                    int r = (p>>16)&0xff;
                    int g = (p>>8)&0xff;
                    int b = p&0xff;
                    
                    //Calculating average per pixel
                    avg = (r+g+b)/3;
                    
                    // Packing back the pixel data
                    p = (a<<24) | (avg<<16) | (avg<<8) | avg;
                    img.setRGB(x, y, p);
                            
                    //Repainting scroll pane to update the changes
                    jScrollPane.repaint();                                      
                }
            }
            //Calculate Unique Colors and Update Status Bar
            uniqueCols.clear();
            colorsCounter = 0;
            countUniqueColors();
            format = 2;
            Estado.setText("Aplicando Escala de Grises | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_EscalaDeGrisesActionPerformed

    private void SinCompresionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SinCompresionActionPerformed
        // TODO add your handling code here:
        String fileData = "";
        int returnVal;
        String ext = "";
        
        if ( img != null ){
            returnVal = fcSave.showSaveDialog(this);
            Estado.setText("Guardando...");
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
            return;
        }
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            switch(format){
                case 1:
                    generatePBM(fcSave.getSelectedFile().getAbsolutePath() + ".pbm");   
                    Estado.setText("Imagen guardada en: " + fcSave.getSelectedFile() + ".pbm");
                    return;
                case 2:
                    fileData = generatePGM();
                    ext = ".pgm";
                    return;
                case 3:
                    fileData = generatePPM();
                    ext = ".ppm";
                    return;
                default:
                    JOptionPane.showMessageDialog(this, "ERROR: La imagen original tiene un formato desconocido. No se puede guardar como Netpbm");
                    break;
            }
        }
    }//GEN-LAST:event_SinCompresionActionPerformed

    private void BlancoNegroActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BlancoNegroActionPerformed
        // TODO add your handling code here:
        //Adding JOptionPane and initializing slider for input
        if (img != null){
            JOptionPane SliderPane = new JOptionPane();
            slider = getSlider(SliderPane);
            SliderPane.setMessage(new Object[] { "Valor del umbral: ", slider });
            SliderPane.setMessageType(JOptionPane.QUESTION_MESSAGE);
            SliderPane.setOptionType(JOptionPane.OK_CANCEL_OPTION);
            JDialog dialog;
            dialog = SliderPane.createDialog(jScrollPane, "Umbral");
            dialog.setVisible(true);

            /*Input Dialog for testing
            String aux = JOptionPane.showInputDialog("Umbral: ");
            int thr;
            thr = Integer.parseInt(aux);*/

            //getting threshold from slider
            int thr;
            //If there's no value from slider and it's unininitialized, assign just half the value
            if (SliderPane.getInputValue() == JOptionPane.UNINITIALIZED_VALUE){
                thr = 127;
            }else{            
                thr = (int)SliderPane.getInputValue();
            }
        
            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                    
                    int avg;
                    // Unpacking the data of each pixel with masks.
                    int p = img.getRGB(x,y);
                    int a = (p>>24)&0xff;
                    int r = (p>>16)&0xff;
                    int g = (p>>8)&0xff;
                    int b = p&0xff;
                    
                    //Calculating average per pixel
                    avg = (r+g+b)/3;
					
                    //Sorting average into range according to threshold
                    if (avg < thr){
                        avg = 0;
                    }else{
                        avg = 255;
                    }
                    //Packing back the pixel data
                    p = (a<<24) | (avg<<16) | (avg<<8) | avg;
                    img.setRGB(x, y, p);
                            
                    //Repainting scroll pane to update the changes
                    jScrollPane.repaint();
                }
            }
            //Calculate Unique Colors and Update Status Bar
            uniqueCols.clear();
            colorsCounter = 0;
            countUniqueColors();
            format = 1;
            Estado.setText("Aplicando Blanco y Negro | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_BlancoNegroActionPerformed

    private void Rotar90CWActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Rotar90CWActionPerformed
        // TODO add your handling code here:
        //Declaring an auxiliary image for operations with Width and Height inverted
        BufferedImage imgAux = null;
        if (img != null){
            int imgW = img.getWidth();
            int imgH = img.getHeight();
            //Declaring an auxiliary image for operations with Width and Height inverted
            imgAux = new BufferedImage(imgH, imgW, BufferedImage.TYPE_3BYTE_BGR);
            for (int i = 0; i < imgW; i++){
                for(int j = 0; j < imgH; j++){
                    imgAux.setRGB(imgH - j - 1, i, img.getRGB(i, j));
                }
            }
            img = imgAux;
            ImageIcon icon = new ImageIcon(img);
            // Adding the ImageIcon to the Label.
            imglabel.setIcon( icon );
            //Aligning the image to the center.
            imglabel.setHorizontalAlignment(JLabel.CENTER);
            //Adding the label to the Scrolling pane.
            jScrollPane.getViewport().add(imglabel);
            Estado.setText("Aplicando Rotación 90°CW | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
        
        
    }//GEN-LAST:event_Rotar90CWActionPerformed

    private void Rotar90CCWActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Rotar90CCWActionPerformed
        // TODO add your handling code here:
        //Declaring an auxiliary image for operations with Width and Height inverted
        BufferedImage imgAux = null;
        if (img != null){
            int imgW = img.getWidth();
            int imgH = img.getHeight();
            //assigning imgAux
            imgAux = new BufferedImage(imgH, imgW, img.getType());
            for (int i = 0; i < imgW; i++){
                for(int j = 0; j < imgH; j++){
                    imgAux.setRGB(j, imgW - 1 - i, img.getRGB(i, j));
                }
            }
            img = imgAux;
            ImageIcon icon = new ImageIcon(img);
            // Adding the ImageIcon to the Label.
            imglabel.setIcon( icon );
            //Aligning the image to the center.
            imglabel.setHorizontalAlignment(JLabel.CENTER);
            //Adding the label to the Scrolling pane.
            jScrollPane.getViewport().add(imglabel);
            Estado.setText("Aplicando Rotación 90°CCW | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
        
    }//GEN-LAST:event_Rotar90CCWActionPerformed

    private void ReadmeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ReadmeActionPerformed
        // TODO add your handling code here:
        Runtime rt = Runtime.getRuntime();
        String readme = ("README.txt");
        try {
            Process p = rt.exec("notepad "+readme);
        } catch (IOException ex) {
            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_ReadmeActionPerformed

    private void AboutActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AboutActionPerformed
        // TODO add your handling code here:
        JOptionPane.showMessageDialog(this, "Editor de Imágenes\nRaquel Escalante y Rafael Vasquez\nSemestre 2-2017\nProcesamiento Digital De Imágenes", "Acerca de", JOptionPane.INFORMATION_MESSAGE);
        
    }//GEN-LAST:event_AboutActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ImageEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ImageEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ImageEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ImageEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            new ImageEditor().setVisible(true);
        });
        
        
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem About;
    private javax.swing.JMenuItem AbrirArchivo;
    private javax.swing.JMenu Ayuda;
    private javax.swing.JPanel BarraEstado;
    private javax.swing.JPanel BarraEstadoPanel;
    private javax.swing.JMenuItem BlancoNegro;
    private javax.swing.JMenuItem CompresionRLE;
    private javax.swing.JMenuItem EscalaDeGrises;
    private javax.swing.JLabel Estado;
    private javax.swing.JMenuItem GuardarBMP;
    private javax.swing.JMenu GuardarNetpbm;
    private javax.swing.JMenu MenuArchivo;
    private javax.swing.JMenuBar MenuBar;
    private javax.swing.JMenu MenuEditar;
    private javax.swing.JMenuItem Negativo;
    private javax.swing.JMenuItem Readme;
    private javax.swing.JMenu Rotacion;
    private javax.swing.JMenuItem Rotar90CCW;
    private javax.swing.JMenuItem Rotar90CW;
    private javax.swing.JPanel ScrollPanePanel;
    private javax.swing.JMenuItem SinCompresion;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JScrollPane jScrollPane;
    // End of variables declaration//GEN-END:variables


    }


