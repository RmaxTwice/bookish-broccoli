
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.WritableRaster;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JSlider;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.filechooser.FileNameExtensionFilter;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Enumeration;
import javax.swing.AbstractButton;
import javax.swing.ButtonGroup;
import javax.swing.JCheckBox;
import javax.swing.JPanel;
import javax.swing.JRadioButton;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Raquel Escalante, Rafael Vasquez
 */
public class ImageEditor extends javax.swing.JFrame {
    
    // Creating a JLabel to display image.
    private JLabel imglabel;
    // Creating a file chooser to open files with
    private JFileChooser fcOpen;
    // Creating a file chooser to save files with
    private JFileChooser fcSave;
    // Properties of the Image
    private int format;
    private int width;
    private int height;
    private int maxColor;
    private BufferedImage img = null;
    // Hashmap and counter used to count unique colors
    private HashMap<Integer, Integer> uniqueCols;
    private int colorsCounter;
    private JSlider thresholdSlider;
    private JSlider kernelSizeSlider;
    
    
    /**
     * Creates new form ImageEditor
     */
    public ImageEditor() {
        initComponents();
        
        imglabel = new JLabel();
        fcOpen = new JFileChooser();
        fcSave = new JFileChooser();
        // Creating file filters for the file choosers
        FileNameExtensionFilter imagesFilter = new FileNameExtensionFilter("Imágenes: *.bmp, *.pbm, *.pgm, *.ppm", "bmp", "pbm", "pgm", "ppm");
        FileNameExtensionFilter savingFilter = new FileNameExtensionFilter("Imágenes RLE: *.rle", "rle");
        fcOpen.addChoosableFileFilter(imagesFilter);
        fcOpen.addChoosableFileFilter(savingFilter);
        fcOpen.setFileFilter(imagesFilter);
        
//        fcSave.addChoosableFileFilter(savingFilter);
//        fcSave.setFileFilter(savingFilter);
        
        uniqueCols = new HashMap<>();
        colorsCounter = 0;
        // Configuring some Slider's properties.
        thresholdSlider = new JSlider(0, 255, 127); // min, max, init
        thresholdSlider.setMajorTickSpacing(50);
        thresholdSlider.setPaintTicks(true);
        thresholdSlider.setPaintLabels(true);
        
        // Configuring some Slider's properties.
        kernelSizeSlider = new JSlider(2, 7, 5); // min, max, init
        kernelSizeSlider.setMajorTickSpacing(1);
        kernelSizeSlider.setPaintTicks(true);
        kernelSizeSlider.setPaintLabels(true);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jMenu1 = new javax.swing.JMenu();
        jMenuItem1 = new javax.swing.JMenuItem();
        ScrollPanePanel = new javax.swing.JPanel();
        jScrollPane = new javax.swing.JScrollPane();
        BarraEstadoPanel = new javax.swing.JPanel();
        BarraEstado = new javax.swing.JPanel();
        Estado = new javax.swing.JLabel();
        MenuBar = new javax.swing.JMenuBar();
        MenuArchivo = new javax.swing.JMenu();
        AbrirArchivo = new javax.swing.JMenuItem();
        GuardarBMP = new javax.swing.JMenuItem();
        GuardarNetpbm = new javax.swing.JMenu();
        SinCompresion = new javax.swing.JMenuItem();
        CompresionRLE = new javax.swing.JMenuItem();
        MenuEditar = new javax.swing.JMenu();
        Negativo = new javax.swing.JMenuItem();
        BlancoNegro = new javax.swing.JMenuItem();
        EscalaDeGrises = new javax.swing.JMenuItem();
        Rotacion = new javax.swing.JMenu();
        Rotar90CW = new javax.swing.JMenuItem();
        Rotar90CCW = new javax.swing.JMenuItem();
        MenuFiltros = new javax.swing.JMenu();
        SuavizadoGaussiano = new javax.swing.JMenuItem();
        Ayuda = new javax.swing.JMenu();
        Readme = new javax.swing.JMenuItem();
        About = new javax.swing.JMenuItem();

        jMenu1.setText("jMenu1");

        jMenuItem1.setText("jMenuItem1");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Editor de Imagenes | by Raquel Escalante & Rafael Vasquez");
        setBounds(new java.awt.Rectangle(0, 0, 800, 600));
        setMaximumSize(getMaximumSize());

        jScrollPane.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        jScrollPane.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        jScrollPane.setDoubleBuffered(true);
        jScrollPane.setPreferredSize(new java.awt.Dimension(1011, 1));

        javax.swing.GroupLayout ScrollPanePanelLayout = new javax.swing.GroupLayout(ScrollPanePanel);
        ScrollPanePanel.setLayout(ScrollPanePanelLayout);
        ScrollPanePanelLayout.setHorizontalGroup(
            ScrollPanePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(ScrollPanePanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 988, Short.MAX_VALUE)
                .addContainerGap())
        );
        ScrollPanePanelLayout.setVerticalGroup(
            ScrollPanePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(ScrollPanePanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 571, Short.MAX_VALUE)
                .addContainerGap())
        );

        BarraEstado.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        Estado.setText("Bienvenido");

        javax.swing.GroupLayout BarraEstadoLayout = new javax.swing.GroupLayout(BarraEstado);
        BarraEstado.setLayout(BarraEstadoLayout);
        BarraEstadoLayout.setHorizontalGroup(
            BarraEstadoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(BarraEstadoLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(Estado)
                .addContainerGap(928, Short.MAX_VALUE))
        );
        BarraEstadoLayout.setVerticalGroup(
            BarraEstadoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(BarraEstadoLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(Estado)
                .addContainerGap())
        );

        javax.swing.GroupLayout BarraEstadoPanelLayout = new javax.swing.GroupLayout(BarraEstadoPanel);
        BarraEstadoPanel.setLayout(BarraEstadoPanelLayout);
        BarraEstadoPanelLayout.setHorizontalGroup(
            BarraEstadoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(BarraEstadoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(BarraEstado, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        BarraEstadoPanelLayout.setVerticalGroup(
            BarraEstadoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(BarraEstadoPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(BarraEstado, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        MenuArchivo.setText("Archivo");

        AbrirArchivo.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        AbrirArchivo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Open16.gif"))); // NOI18N
        AbrirArchivo.setText("Abrir Imagen...");
        AbrirArchivo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AbrirArchivoActionPerformed(evt);
            }
        });
        MenuArchivo.add(AbrirArchivo);

        GuardarBMP.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        GuardarBMP.setIcon(new javax.swing.ImageIcon(getClass().getResource("/SaveBMP.gif"))); // NOI18N
        GuardarBMP.setText("Guardar BMP");
        GuardarBMP.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                GuardarBMPActionPerformed(evt);
            }
        });
        MenuArchivo.add(GuardarBMP);

        GuardarNetpbm.setText("Guardar Netpbm");

        SinCompresion.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.SHIFT_MASK));
        SinCompresion.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Save16.gif"))); // NOI18N
        SinCompresion.setText("Sin Compresión");
        SinCompresion.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SinCompresionActionPerformed(evt);
            }
        });
        GuardarNetpbm.add(SinCompresion);

        CompresionRLE.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        CompresionRLE.setIcon(new javax.swing.ImageIcon(getClass().getResource("/SaveRLE.gif"))); // NOI18N
        CompresionRLE.setText("Con compresión RLE");
        CompresionRLE.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CompresionRLEActionPerformed(evt);
            }
        });
        GuardarNetpbm.add(CompresionRLE);

        MenuArchivo.add(GuardarNetpbm);

        MenuBar.add(MenuArchivo);

        MenuEditar.setText("Editar");

        Negativo.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_N, java.awt.event.InputEvent.CTRL_MASK));
        Negativo.setText("Negativo");
        Negativo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                NegativoActionPerformed(evt);
            }
        });
        MenuEditar.add(Negativo);

        BlancoNegro.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_B, java.awt.event.InputEvent.CTRL_MASK));
        BlancoNegro.setText("Blanco y Negro");
        BlancoNegro.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                BlancoNegroActionPerformed(evt);
            }
        });
        MenuEditar.add(BlancoNegro);

        EscalaDeGrises.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_G, java.awt.event.InputEvent.CTRL_MASK));
        EscalaDeGrises.setText("Escala de Grises");
        EscalaDeGrises.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                EscalaDeGrisesActionPerformed(evt);
            }
        });
        MenuEditar.add(EscalaDeGrises);

        Rotacion.setText("Rotación");

        Rotar90CW.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_RIGHT, java.awt.event.InputEvent.CTRL_MASK));
        Rotar90CW.setText("90° CW");
        Rotar90CW.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Rotar90CWActionPerformed(evt);
            }
        });
        Rotacion.add(Rotar90CW);

        Rotar90CCW.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_LEFT, java.awt.event.InputEvent.CTRL_MASK));
        Rotar90CCW.setText("90° CCW");
        Rotar90CCW.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Rotar90CCWActionPerformed(evt);
            }
        });
        Rotacion.add(Rotar90CCW);

        MenuEditar.add(Rotacion);

        MenuBar.add(MenuEditar);

        MenuFiltros.setText("Filtros");

        SuavizadoGaussiano.setText("Suavizado Gaussiano");
        SuavizadoGaussiano.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SuavizadoGaussianoActionPerformed(evt);
            }
        });
        MenuFiltros.add(SuavizadoGaussiano);

        MenuBar.add(MenuFiltros);

        Ayuda.setText("Ayuda");

        Readme.setText("Léeme");
        Readme.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ReadmeActionPerformed(evt);
            }
        });
        Ayuda.add(Readme);

        About.setText("Acerca De...");
        About.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AboutActionPerformed(evt);
            }
        });
        Ayuda.add(About);

        MenuBar.add(Ayuda);

        setJMenuBar(MenuBar);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(ScrollPanePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
            .addComponent(BarraEstadoPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(ScrollPanePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(BarraEstadoPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    
    /**
     * 
     * @param evt 
     */
    
    private String getSelectedButtonText(ButtonGroup buttonGroup) {
        for (Enumeration<AbstractButton> buttons = buttonGroup.getElements(); buttons.hasMoreElements();) {
            AbstractButton button = buttons.nextElement();

            if (button.isSelected()) {
                return button.getText();
            }
        }

        return null;
    }

    private void writeRLEFile(String filename){
        int currentColor;
        int inColor;
        int counter = 0;
        if (img != null){
            try(FileWriter fw = new FileWriter(filename + ".rle")) {
                // Initializing the data with a header according to the format
                switch(format){
                    case 1:
                        fw.write("P1 \n" + width + " " + height + "\n");
                        break;
                    case 2:
                        fw.write("P2 \n" + width + " " + height + "\n");
                        break;
                    case 3:
                        fw.write("P3 \n" + width + " " + height + "\n");
                }
                // This function will create a big array with all the pixel RGB values.
                int[] pixelDataBuffInt = img.getRGB(0, 0, width, height, null, 0, width);
                int maxSize = pixelDataBuffInt.length;

                // Initializing the very first pixel value
                currentColor = pixelDataBuffInt[0];

                for(int i = 0; i < maxSize; i++){
                    // Reading next pixel value
                    inColor = pixelDataBuffInt[i];

                    // If the colors are different write the count to the file and reset
                    if ( inColor != currentColor ){
                        //Writing data to the file according to the format
                        switch(format){
                            case 1: //1 = Black and 0 = White
                                if (((currentColor >> 16) & 0xff) == 0){
                                    fw.write(counter + " 1 ");
                                }else{
                                    fw.write(counter + " 0 ");
                                }
                                break;
                            case 2: // Just the red value.
                                fw.write(counter + " " + ((currentColor >> 16) & 0xff) + " ");
                                break;
                            case 3: // Red, green and blue values together as the same int value.
                                fw.write(counter + " " + currentColor  + " ");   // red, green and blue
                        }

                        currentColor = inColor;
                        counter = 1;
                    }else{
                        counter++;
                    }
                }
                //Writing the last color ocurrence to the file according to the format
                switch(format){
                    case 1: //1 = Black and 0 = White
                        if (((currentColor >> 16) & 0xff) == 0){
                            fw.write(counter + " 1 ");
                        }else{
                            fw.write(counter + " 0 ");
                        }
                        break;
                    case 2: // Just the red value.
                        fw.write(counter + " " + ((currentColor >> 16) & 0xff) + " ");
                        break;
                    case 3: // Red, green and blue values.
                        fw.write(counter + " " + currentColor  + " ");   // red, green and blue
                }

                fw.close();
                Estado.setText("Imagen guardada en: " + filename + ".rle");
            }catch (IOException ex) {
                    Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }

    private void writeNetPBMFile(String filename){
        String ext = "";
        switch(format){
            case 1:
                ext = ".pbm";
                break;
            case 2:
                ext = ".pgm";
                break;
            case 3:
                ext = ".ppm";
        }
        
        if (img != null){
            try(FileWriter fw = new FileWriter(filename + ext)) {
//                long startTime = System.currentTimeMillis();

                // Initializing the data with a header according to the format
                switch(format){
                    case 1:
                        fw.write("P1 \n" + width + " " + height);
                        break;
                    case 2:
                        fw.write("P2 \n" + width + " " + height + " \n" + maxColor);
                        break;
                    case 3:
                        fw.write("P3 \n" + width + " " + height + " \n" + maxColor);
                }
                // This function will create a big array with all the pixel RGB values.
                int[] pixelDataBuffInt = img.getRGB(0, 0, width, height, null, 0, width);

                int maxSize = pixelDataBuffInt.length;
//                long endTime = System.currentTimeMillis();
//                System.out.println("That took " + (endTime - startTime) + " milliseconds");
                for(int i = 0; i < maxSize; i++){
                    // Adding end of line after each row.
                    if (i % width == 0){
                        fw.write("\n");
                    }

                    //Writing data to the file according to the format
                    switch(format){
                        case 1: //1 = Black and 0 = White
                            if (((pixelDataBuffInt[i] >> 16) & 0xff) == 0){
                                fw.write(" 1 ");
                            }else{
                                fw.write(" 0 ");
                            }
                            break;
                        case 2: // Just the red value.
                            fw.write(((pixelDataBuffInt[i] >> 16) & 0xff) + " ");
                            break;
                        case 3: // Red, green and blue values.   
                            fw.write(((pixelDataBuffInt[i] >> 16) & 0xff) + " ");   // red
                            fw.write(((pixelDataBuffInt[i] >> 8) & 0xff) + " ");    // green
                            fw.write((pixelDataBuffInt[i] & 0xff) + " ");           // blue
                    }
                    
                }
//                endTime = System.currentTimeMillis();
//                System.out.println("That took " + (endTime - startTime) + " milliseconds");
                fw.close();
                Estado.setText("Imagen guardada en: " + filename + ext);
            }catch (IOException ex) {
                    Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
    
    private void countUniqueColors(){
        int key;
        if (img != null){
            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                    // Unpacking the color data of each pixel.
                    key = img.getRGB(x,y);
                    
                    // If the color has not been counted.
                    if (uniqueCols.get(key) == null){
                        uniqueCols.put(key, 1);
                        colorsCounter++;
                    } 
                }
            }
        }
    }
    
    private BufferedImage readPBMfromRLE(int width, int height, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int value = 0;
        int row = 0;
        int col = 0;
        int freq = 0;
        while (parser.ttype != StreamTokenizer.TT_EOF){
            try {
                // Reading next token:
                //System.out.println( " 1)current parser value: " + parser.nval );
                parser.nextToken();
                freq = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            if (parser.ttype == StreamTokenizer.TT_EOF){
                //System.out.println( " End of file "  );
                break;
            }
            try {
                // Reading next token:
                parser.nextToken();
                value = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            if (value == 1){
                value = 0;
            }else{
                value = 255;
            }
            for(int i = 0; i<freq; i++ ){
                raster.setSample(col, row, 0, value);
                raster.setSample(col, row, 1, value);
                raster.setSample(col, row, 2, value);
                col++;
                if (col >= width){
                    col = 0;
                    row++;
                }
            }  
        }
        
        return imgTemp;
    }

    private BufferedImage readPGMfromRLE(int width, int height, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int value = 0;
        int row = 0;
        int col = 0;
        int freq = 0;
        //int numTokens = 0;
        while (parser.ttype != StreamTokenizer.TT_EOF){
            try {
                // Reading next token:
                //System.out.println( " 1)current parser value: " + parser.nval );
                parser.nextToken();
                freq = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            if (parser.ttype == StreamTokenizer.TT_EOF){
                //System.out.println( " End of file "  );
                break;
            }
            try {
                // Reading next token:
                parser.nextToken();
                value = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            
            
            for(int i = 0; i<freq; i++ ){
                try{
                    raster.setSample(col, row, 0, value); // R
                    raster.setSample(col, row, 1, value); // G
                    raster.setSample(col, row, 2, value); // B
                    col++;
                    if (col >= width){
                        col = 0;
                        row++;
                    }
                }catch(ArrayIndexOutOfBoundsException e){
                    //System.out.println( "Width: "+ width + "  Height: " + height + "  c: " + col + "  r: " + row + " freq: " + freq + " val: " + value);
                    JOptionPane.showMessageDialog(this, "La imagen está corrompida.");
                    break;
                }
            }  
        }
        return imgTemp;
    }

    private BufferedImage readPPMfromRLE(int width, int height, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int value = 0;
        int row = 0;
        int col = 0;
        int freq = 0;
        while (parser.ttype != StreamTokenizer.TT_EOF){
            try {
                // Reading next token:
                //System.out.println( " 1)current parser value: " + parser.nval );
                parser.nextToken();
                freq = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            if (parser.ttype == StreamTokenizer.TT_EOF){
                //System.out.println( " End of file "  );
                break;
            }
            try {
                // Reading next token:
                parser.nextToken();
                value = (int)parser.nval;
            } catch (IOException ex) {
                Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
            }
            
            int r = (value >> 16) & 0xff;
            int g = (value >> 8) & 0xff;
            int b = value & 0xff;
            
            for(int i = 0; i<freq; i++ ){
                raster.setSample(col, row, 0, r); // R
                raster.setSample(col, row, 1, g); // G
                raster.setSample(col, row, 2, b); // B
                col++;
                if (col >= width){
                    col = 0;
                    row++;
                }
            }  
        }
        return imgTemp;
    }

    private BufferedImage readPPM(int width, int height, int maxCol, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int value;
        for (int y = 0; y < height; ++y)
            for (int x = 0; x < width; ++x)
                for (int i = 0; i < 3; ++i) {

                    try {
                       // Reading next token:
                       parser.nextToken();
                    } catch (IOException ex) {
                        Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    // If the current token is eof before reading all the width and height of bytes then exit.
                    if (parser.ttype == StreamTokenizer.TT_EOF){
                        JOptionPane.showMessageDialog(this, "La imagen está posiblemente truncada");
                        return null;
                    }
                    // If the current token is not a number then exit.
                    if (parser.ttype != StreamTokenizer.TT_NUMBER){
                        JOptionPane.showMessageDialog(this, "Valor no numerico para la muestra" + i + " del pixel en (" + x + "," + y + ")");
                        return null;
                    }
                    // Rasterizing the data
                    value = ((int)parser.nval * 255)/ maxCol;
                    raster.setSample(x, y, i, value);
                }
        return imgTemp;
    }

    private BufferedImage readPGM(int width, int height,int maxCol, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int pixelValue;
        for (int y = 0; y < height; ++y)
            for (int x = 0; x < width; ++x)
                for (int i = 0; i < 1; ++i) {
                    try {
                       // Reading next token:
                       parser.nextToken();
                    } catch (IOException ex) {
                        Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    // If the current token is eof before reading all the width and height of bytes then exit.
                    if (parser.ttype == StreamTokenizer.TT_EOF){
                        JOptionPane.showMessageDialog(this, "La imagen está posiblemente truncada");
                        return null;
                    }
                    // If the current token is not a number then exit.
                    if (parser.ttype != StreamTokenizer.TT_NUMBER){
                        JOptionPane.showMessageDialog(this, "Valor no numerico para la muestra" + i + " del pixel en (" + x + "," + y + ")");
                        return null;
                    }
                    // Resterizingthe data
                    pixelValue = ((int)parser.nval * 255)/ maxCol;
                    raster.setSample(x, y, 0, pixelValue);// R
                    raster.setSample(x, y, 1, pixelValue);// G
                    raster.setSample(x, y, 2, pixelValue);// B
                }
        return imgTemp;
    }

    private BufferedImage readPBM(int width, int height, StreamTokenizer parser){
        // Proceeding to read the image data and render it with a WritableRaster class
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        WritableRaster raster = imgTemp.getRaster();
        int pixelValue;
        for (int y = 0; y < height; ++y)
            for (int x = 0; x < width; ++x)
                for (int i = 0; i < 1; ++i) {

                    try {
                       // Reading next token:
                       parser.nextToken();
                    } catch (IOException ex) {
                        Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    // If the current token is eof before reading all the width and height of bytes then exit.
                    if (parser.ttype == StreamTokenizer.TT_EOF){
                        JOptionPane.showMessageDialog(this, "La imagen está posiblemente truncada");
                        return null;
                    }
                    // If the current token is not a number then exit.
                    if (parser.ttype != StreamTokenizer.TT_NUMBER){
                        JOptionPane.showMessageDialog(this, "Valor no numerico para la muestra" + i + " del pixel en (" + x + "," + y + ")");
                        return null;
                    }
                    // Rasterizing the data and inverting values because 1 = black and 0 = white in this format.
                    pixelValue = (int)parser.nval ;
                    if (pixelValue == 1){
                        raster.setSample(x, y, 0, 0);
                        raster.setSample(x, y, 1, 0);
                        raster.setSample(x, y, 2, 0);
                    }else{
                        raster.setSample(x, y, 0, 255);
                        raster.setSample(x, y, 1, 255);
                        raster.setSample(x, y, 2, 255);
                    }
                    
                }
        return imgTemp;
    }

    private int convolutionFunction(int krnlVal, int[] kernl, ArrayList r, ArrayList g, ArrayList b) throws RuntimeException{
        int krnlSize = kernl.length;
        int rTotal = 0;
        int gTotal = 0;
        int bTotal = 0;
        // If all the kernels have the same length then we can convolute.
        if(krnlSize == r.size() && r.size() == g.size() && g.size() == b.size()){
            for(int i = 0 ; i < krnlSize; i++){
                rTotal += (int)r.get(i) * kernl[i];
                gTotal += (int)g.get(i) * kernl[i];
                bTotal += (int)b.get(i) * kernl[i];
            }

            rTotal /= krnlVal;
            gTotal /= krnlVal;
            bTotal /= krnlVal;
        }else{
        // Error: Can't calculate convolution.
          throw new RuntimeException("Error en la convolución.");  //JOptionPane.showMessageDialog(this, "¡ERROR: Error en la convolusion!");
        }
        return (255<<24) | (rTotal<<16) | (gTotal<<8) | bTotal;
    }

    private void GaussianBlurController(int[] kernel, int kernelSize, int kernelValue, boolean Vert, boolean Horiz ) throws RuntimeException{
        BufferedImage imgTemp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
        int i;
        int j;
        int k;
        int pvalue;
        int kernelPivotIndex = 0;
        boolean odd = false;
        if (kernelSize%2 == 0){
            kernelPivotIndex = kernelSize/2 - 1;
        }else{
            kernelPivotIndex = kernelSize/2;
            odd = true;
        }

        if (Horiz){
            // These ArrayLists serve as sliding windows per color channel (Horizontal).
            ArrayList redH = new ArrayList();
            ArrayList greenH = new ArrayList();
            ArrayList blueH = new ArrayList();

            //This cycles choose the pivot pixel and where to write in the temp image. (Row by Row)
            for(i = 0; i < height; i++){
                redH.clear();
                greenH.clear();
                blueH.clear();
                // The values outside of the kernel are equal to 0
                for(k = 0; k < kernelPivotIndex; k++){
                    redH.add(0);
                    greenH.add(0);
                    blueH.add(0);
                }
                if (odd){
                    for(k = 0; k < kernelPivotIndex + 1; k++){
                        pvalue = img.getRGB(k, i);
                        redH.add((pvalue >> 16) & 0xff);
                        greenH.add((pvalue >> 8) & 0xff);
                        blueH.add(pvalue & 0xff);
                    }
                }else{
                    for(k = 0; k < kernelPivotIndex + 2; k++){
                        pvalue = img.getRGB(k, i);
                        redH.add((pvalue >> 16) & 0xff);
                        greenH.add((pvalue >> 8) & 0xff);
                        blueH.add(pvalue & 0xff);
                    }
                }

                for(j = 0; j < width; j++){
                    int newPixelValue = 0;
                    try{
                        newPixelValue = convolutionFunction(kernelValue, kernel, redH, greenH, blueH);
                    }catch(RuntimeException re){
                        throw new RuntimeException("No se pudo aplicar filtro gaussiano.",re);
                    }
                    imgTemp.setRGB(j, i, newPixelValue);
                    // Shifting sliding windows to the right by one pixel, if the kernel is out of bounds, complete with 0's.
                    int x = 0;
                    if(odd){
                        x = j + 1 + kernelPivotIndex;
                    }else{
                        x = j + 2 + kernelPivotIndex;
                    }

                    if (x >= width){
                        redH.add(0);
                        greenH.add(0);
                        blueH.add(0);
                    }else{
                        pvalue = img.getRGB(x, i);
                        redH.add((pvalue >> 16) & 0xff);
                        greenH.add((pvalue >> 8) & 0xff);
                        blueH.add(pvalue & 0xff);
                    }

                    redH.remove(0);
                    greenH.remove(0);
                    blueH.remove(0);
                }
            }
            redH.clear();
            greenH.clear();
            blueH.clear();
            img = imgTemp;
        }

        if(Vert){
            // These ArrayLists serve as sliding windows per color channel (Vertical).
            ArrayList redV = new ArrayList();
            ArrayList greenV = new ArrayList();
            ArrayList blueV = new ArrayList();

            //This cycles choose the pivot pixel and where to write in the temp image. (Column by Column)
            for(j = 0; j < width; j++){
                redV.clear();
                greenV.clear();
                blueV.clear();
                // The values outside of the kernel are equal to 0
                for(k = 0; k < kernelPivotIndex; k++){
                    redV.add(0);
                    greenV.add(0);
                    blueV.add(0);
                }
                if (odd){
                    for(k = 0; k < kernelPivotIndex + 1; k++){
                        pvalue = img.getRGB(j, k);
                        redV.add((pvalue >> 16) & 0xff);
                        greenV.add((pvalue >> 8) & 0xff);
                        blueV.add(pvalue & 0xff);
                    }
                }else{
                    for(k = 0; k < kernelPivotIndex + 2; k++){
                        pvalue = img.getRGB(j, k);
                        redV.add((pvalue >> 16) & 0xff);
                        greenV.add((pvalue >> 8) & 0xff);
                        blueV.add(pvalue & 0xff);
                    }
                }

                for(i = 0; i < height; i++){
                    int newPixelValue = 0;
                    try{
                        newPixelValue = convolutionFunction(kernelValue, kernel, redV, greenV, blueV);
                    }catch(RuntimeException re){
                        throw new RuntimeException("No se pudo aplicar filtro gaussiano.",re);
                    }
                    imgTemp.setRGB(j, i, newPixelValue);
                    // Shifting sliding windows to the right by one pixel, if the kernel is out of bounds, complete with 0's.
                    int y = 0;
                    if(odd){
                        y = i + 1 + kernelPivotIndex;
                    }else{
                        y = i + 2 + kernelPivotIndex;
                    }

                    if (y >= height){
                        redV.add(0);
                        greenV.add(0);
                        blueV.add(0);
                    }else{
                        pvalue = img.getRGB(j , y);
                        redV.add((pvalue >> 16) & 0xff);
                        greenV.add((pvalue >> 8) & 0xff);
                        blueV.add(pvalue & 0xff);
                    }
                    redV.remove(0);
                    greenV.remove(0);
                    blueV.remove(0);
                }
            }
            img = imgTemp;
        }
    }

    private int[] getGaussianKernel(int n){
        int[] k = null;
        switch(n){
            case 2:
                k = new int[] {1,1};
                return k;
            case 3:
                k = new int[] {1,2,1};
                return k;
            case 4:
                k = new int[] {1,3,3,1};
                return k;
            case 5:
                k = new int[] {1,4,6,4,1};
                return k;
            case 6:
                k = new int[] {1,5,10,10,5,1};
                return k;
            case 7:
                k = new int[] {1,6,15,20,15,6,1};
                return k;
        }
        return k;
    }

    //Function to set parameters of B&W slider
    /**private JSlider getSlider(JOptionPane SliderPane) {
        JSlider sliderAux = new JSlider(0, 255);
        sliderAux.setMajorTickSpacing(50);
        sliderAux.setPaintTicks(true);
        sliderAux.setPaintLabels(true);
        ChangeListener changeListener = new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent changeEvent) {
                JSlider theSlider = (JSlider) changeEvent.getSource();
                if (!theSlider.getValueIsAdjusting()) {
                    SliderPane.setInputValue(new Integer(theSlider.getValue()));
                }
            }
        };
        sliderAux.addChangeListener(changeListener);
        return sliderAux;
    }*/

    // This function provides a ChangeListener based on a JOptionPane that will
    // listen anychanges made in a JOptionsPane
    private ChangeListener createChangeListener(JOptionPane Pane) {
        ChangeListener changeListener = new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent changeEvent) {
                JSlider theSlider = (JSlider) changeEvent.getSource();
                if (!theSlider.getValueIsAdjusting()) {
                    Pane.setInputValue(theSlider.getValue());
                }
            }
        };
        return changeListener;
    }

    private void GuardarBMPActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_GuardarBMPActionPerformed
        // TODO add your handling code here:
        int returnVal;
        
        if ( img != null ){
            returnVal = fcSave.showSaveDialog(this); 
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
            return;
        }
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            
            try {
                //RenderedImage rendImage = bi;
                ImageIO.write(img, "bmp", new File(fcSave.getSelectedFile().getAbsolutePath()+".bmp"));
                Estado.setText("Imagen guardada en: " + fcSave.getSelectedFile().getAbsolutePath()+".bmp");
            } catch ( IOException e) {
                e.printStackTrace();
            }
        }
        
    }//GEN-LAST:event_GuardarBMPActionPerformed

    private void AbrirArchivoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AbrirArchivoActionPerformed
        // TODO add your handling code here:
        // The image variable
        img = null;
        // Resetting unique colors container for new image.
        uniqueCols.clear();
        colorsCounter = 0;
        
        FileInputStream in = null;
        StreamTokenizer parser;
        BufferedReader reader;
        //In response to a button click, the file chooser is displayed
        int returnVal = fcOpen.showOpenDialog(this);
        
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File file = fcOpen.getSelectedFile();
            // Now open the file.
            //JOptionPane.showMessageDialog(this, file.getAbsolutePath());
            // Getting the image extension.
            String path = file.getAbsolutePath();
            String extension = path.substring(path.length() - 3);
            
            if(null != extension){
                // Are we opening a bmp image?
                switch (extension) {
                    case "bmp":
                        try {
                            // Filling BufferedImage with file information
                            img = ImageIO.read(file);
                            // Making note of image properties
                            format = 3;
                            width = img.getWidth();
                            height = img.getHeight();
                            maxColor = 255;
                            //JOptionPane.showMessageDialog(this, "Imagen tipo: " + types);
                        } catch (IOException e) {
                            // Report exceptions
                            JOptionPane.showMessageDialog(this, "Error al Abrir Imagen!");
                        }
                        break;
                        //log.append("Opening: " + file.getName() + "." + newline);
                    // Are we opening a Netpbm image?
                    case "ppm":
                    case "pgm":
                    case "pbm":
                        // Creating a FileInputStream to be used by the BufferedReader
                        
                        try {
                            in = new FileInputStream( path );
                        } catch (FileNotFoundException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }

                        
                        reader = new BufferedReader(new InputStreamReader(in));
                        parser = new StreamTokenizer(reader);
                        // Filtering out comments from the data
                        parser.commentChar('#');

                        try {
                            // Reading Header(Magic Number):
                           parser.nextToken();
                        } catch (IOException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }

                        // Processing the magic number. (Pending verify this is actually a String)
                        switch(parser.sval){
                            // PBM format
                            case "P1":
                                format = 1;
                                maxColor = 1;
                                break;
                            case "P2":
                                format = 2;
                                break;
                            case "P3":
                                format = 3;
                                break;
                        }

                        //JOptionPane.showMessageDialog(this, format );

                        // Reading image properties from header: Width, Height, max color(optional)
                        try {
                            // Reading Header:
                           parser.nextToken();
                           width = (int)parser.nval;
                           parser.nextToken();
                           height = (int)parser.nval;

                           if (format != 1){
                               parser.nextToken();
                               maxColor = (int)parser.nval;
                           }
                        } catch (IOException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }
                        //JOptionPane.showMessageDialog(this, "W:" + width + " H:" + height + " MaxC:" + maxColor);

                        // Proceeding to read the image data 
                        switch(format){
                            case 1:
                                img = readPBM(width, height, parser);
                                break;
                            case 2:
                                img = readPGM(width, height, maxColor, parser);
                                break;
                            case 3:
                                img = readPPM(width, height, maxColor, parser);
                                break;
                        }
                        break;
                    case "rle":
                        try {
                            in = new FileInputStream( path );
                        } catch (FileNotFoundException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }

                        reader = new BufferedReader(new InputStreamReader(in));
                        parser = new StreamTokenizer(reader);

                        try {
                            // Reading Header(Magic Number):
                           parser.nextToken();
                        } catch (IOException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }

                        // Processing the magic number. (Pending verify this is actually a String)
                        switch(parser.sval){
                            // PBM format
                            case "P1":
                                format = 1;
                                maxColor = 1;
                                break;
                            case "P2":
                                format = 2;
                                break;
                            case "P3":
                                format = 3;
                                break;
                        }

                        //JOptionPane.showMessageDialog(this, format );

                        // Reading image properties from header: Width, Height, max color(optional)
                        try {
                            // Reading Header:
                           parser.nextToken();
                           width = (int)parser.nval;
                           parser.nextToken();
                           height = (int)parser.nval;
                        } catch (IOException ex) {
                            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
                        }
                        //JOptionPane.showMessageDialog(this, "W:" + width + " H:" + height + " MaxC:" + maxColor);

                        // Proceeding to read the image data 
                        switch(format){
                            case 1:
                                img = readPBMfromRLE(width, height, parser);
                                break;
                            case 2:
                                img = readPGMfromRLE(width, height, parser);
                                break;
                            case 3:
                                img = readPPMfromRLE(width, height, parser);
                                break;
                        }
                        break;
                }
                
                ImageIcon icon = new ImageIcon(img);
                // Adding the ImageIcon to the Label.
                imglabel.setIcon( icon );
                //Aligning the image to the center.
                imglabel.setHorizontalAlignment(JLabel.CENTER);
                //Adding the label to the Scrolling pane.
                jScrollPane.getViewport().add(imglabel);

                // Counting unique colors
                countUniqueColors();
                
                //Changing Estado Label
                Estado.setText("Abriendo " + file.getAbsolutePath() + " | Colores Únicos en imagen: " + colorsCounter);
            }
        } else {
            // Cancel opening.
            //JOptionPane.showMessageDialog(this, "Opening file canceled.");
            //log.append("Open command cancelled by user." + newline);
        }
    }//GEN-LAST:event_AbrirArchivoActionPerformed

    private void NegativoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_NegativoActionPerformed
        // TODO add your handling code here:
        if (img != null){
            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                    // Unpacking the data of each pixel with masks.
                    int p = img.getRGB(x, y);
                    int a = (p >> 24) & 0xff;
                    int r = (p >> 16) & 0xff;
                    int g = (p >> 8) & 0xff;
                    int b = p & 0xff;

                    // Inverting the colors of the pixel per sample.
                    r = 255 - r;
                    g = 255 - g;
                    b = 255 - b;

                    // Packing back the pixel data
                    p = (a<<24) | (r<<16) | (g<<8) | b;
                    img.setRGB(x, y, p);

                    // Repainting the scroll pane to update the changes
                    jScrollPane.repaint();
                    // Updating status bar.
                    Estado.setText("Aplicando Negativo | Colores Únicos en imagen: " + colorsCounter);
                }
            }    
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_NegativoActionPerformed

    private void CompresionRLEActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CompresionRLEActionPerformed
        int returnVal;

        if ( img != null ){
            returnVal = fcSave.showSaveDialog(this);
            if (returnVal == JFileChooser.APPROVE_OPTION) {
                if (format >= 1 && format <= 3)
                    writeRLEFile(fcSave.getSelectedFile().getAbsolutePath());
                else
                   JOptionPane.showMessageDialog(this, "¡ERROR: Error de Formato!");
            }
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
            return;
        }
    }//GEN-LAST:event_CompresionRLEActionPerformed

    private void EscalaDeGrisesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_EscalaDeGrisesActionPerformed
        // TODO add your handling code here:
        if (img != null){
            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                    int avg;
                    // Unpacking the data of each pixel with masks.
                    int p = img.getRGB(x,y);
                    int a = (p>>24)&0xff;
                    int r = (p>>16)&0xff;
                    int g = (p>>8)&0xff;
                    int b = p&0xff;
                    
                    //Calculating average per pixel
                    avg = (r+g+b)/3;
                    
                    // Packing back the pixel data
                    p = (a<<24) | (avg<<16) | (avg<<8) | avg;
                    img.setRGB(x, y, p);
                            
                    //Repainting scroll pane to update the changes
                    jScrollPane.repaint();                                      
                }
            }
            //Calculate Unique Colors and Update Status Bar
            uniqueCols.clear();
            colorsCounter = 0;
            countUniqueColors();
            format = 2;
            Estado.setText("Aplicando Escala de Grises | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_EscalaDeGrisesActionPerformed

    private void SinCompresionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SinCompresionActionPerformed
        int returnVal;

        if ( img != null ){
            returnVal = fcSave.showSaveDialog(this);
            if (returnVal == JFileChooser.APPROVE_OPTION) {
                if (format >= 1 && format <= 3)
                    writeNetPBMFile(fcSave.getSelectedFile().getAbsolutePath());
                else
                   JOptionPane.showMessageDialog(this, "¡ERROR: Error de Formato!"); 
            }
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
            return;
        } 
    }//GEN-LAST:event_SinCompresionActionPerformed

    private void BlancoNegroActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BlancoNegroActionPerformed
        if (img != null){
            /** JOptionPane SliderPane = new JOptionPane();
            //Creating a ChangeListener so the changes in the JOptionPane get reflected to the slider.
            thresholdSlider.addChangeListener(createChangeListener( SliderPane ));
            SliderPane.setMessage(new Object[] { "Valor del umbral: ", thresholdSlider });
            SliderPane.setMessageType(JOptionPane.QUESTION_MESSAGE);
            SliderPane.setOptionType(JOptionPane.OK_CANCEL_OPTION);
            JDialog dialog;
            dialog = SliderPane.createDialog(jScrollPane, "Umbral");
            dialog.setVisible(true); */

            Object[] params = {"Valor del umbral: ", thresholdSlider};
            Object[] options = {"Aceptar", "Cancelar"};
            int result = JOptionPane.showOptionDialog(  ScrollPanePanel,
                                                        params,
                                                        "Opciones de Umbralización",
                                                        JOptionPane.YES_NO_OPTION,
                                                        JOptionPane.QUESTION_MESSAGE,
                                                        null,           // Don't use a custom Icon
                                                        options,        // The strings of buttons
                                                        options[0]);    // Default button title
            // Getting threshold value from the slider
            int thr = thresholdSlider.getValue();
            //If the operation was canceled do nothing.
            if (result == JOptionPane.NO_OPTION){
                return;
            }

            for(int y = 0; y < height; y++){
                for(int x = 0; x < width; x++){
                    
                    int avg;
                    // Unpacking the data of each pixel with masks.
                    int p = img.getRGB(x,y);
                    int a = (p>>24)&0xff;
                    int r = (p>>16)&0xff;
                    int g = (p>>8)&0xff;
                    int b = p&0xff;
                    
                    //Calculating average per pixel
                    avg = (r+g+b)/3;
					
                    //Sorting average into range according to threshold
                    if (avg < thr){
                        avg = 0;
                    }else{
                        avg = 255;
                    }
                    //Packing back the pixel data
                    p = (a<<24) | (avg<<16) | (avg<<8) | avg;
                    img.setRGB(x, y, p);
                            
                    //Repainting scroll pane to update the changes
                    jScrollPane.repaint();
                }
            }
            //Calculate Unique Colors and Update Status Bar
            uniqueCols.clear();
            colorsCounter = 0;
            countUniqueColors();
            format = 1;
            Estado.setText("Aplicando Blanco y Negro | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_BlancoNegroActionPerformed

    private void Rotar90CWActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Rotar90CWActionPerformed
        //Declaring an auxiliary image for operations with Width and Height inverted
        if (img != null){
            int imgW = img.getWidth();
            int imgH = img.getHeight();
            //Declaring an auxiliary image for operations with Width and Height inverted
            BufferedImage imgAux = new BufferedImage(imgH, imgW, BufferedImage.TYPE_3BYTE_BGR);
            for (int i = 0; i < imgW; i++){
                for(int j = 0; j < imgH; j++){
                    imgAux.setRGB(imgH - j - 1, i, img.getRGB(i, j));
                }
            }
            img = imgAux;
            ImageIcon icon = new ImageIcon(img);
            // Adding the ImageIcon to the Label.
            imglabel.setIcon( icon );
            //Aligning the image to the center.
            imglabel.setHorizontalAlignment(JLabel.CENTER);
            //Adding the label to the Scrolling pane.
            jScrollPane.getViewport().add(imglabel);
            Estado.setText("Aplicando Rotación 90°CW | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
        
        
    }//GEN-LAST:event_Rotar90CWActionPerformed

    private void Rotar90CCWActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Rotar90CCWActionPerformed
        // TODO add your handling code here:
        //Declaring an auxiliary image for operations with Width and Height inverted
        BufferedImage imgAux = null;
        if (img != null){
            int imgW = img.getWidth();
            int imgH = img.getHeight();
            //assigning imgAux
            imgAux = new BufferedImage(imgH, imgW, img.getType());
            for (int i = 0; i < imgW; i++){
                for(int j = 0; j < imgH; j++){
                    imgAux.setRGB(j, imgW - 1 - i, img.getRGB(i, j));
                }
            }
            img = imgAux;
            ImageIcon icon = new ImageIcon(img);
            // Adding the ImageIcon to the Label.
            imglabel.setIcon( icon );
            //Aligning the image to the center.
            imglabel.setHorizontalAlignment(JLabel.CENTER);
            //Adding the label to the Scrolling pane.
            jScrollPane.getViewport().add(imglabel);
            Estado.setText("Aplicando Rotación 90°CCW | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
        
    }//GEN-LAST:event_Rotar90CCWActionPerformed

    private void ReadmeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ReadmeActionPerformed
        // TODO add your handling code here:
        Runtime rt = Runtime.getRuntime();
        String readme = ("README.txt");
        try {
            Process p = rt.exec("notepad "+readme);
        } catch (IOException ex) {
            Logger.getLogger(ImageEditor.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_ReadmeActionPerformed

    private void AboutActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AboutActionPerformed
        // TODO add your handling code here:
        JOptionPane.showMessageDialog(this, "Editor de Imágenes\nRaquel Escalante y Rafael Vasquez\nSemestre 2-2017\nProcesamiento Digital De Imágenes", "Acerca de", JOptionPane.INFORMATION_MESSAGE);
        
    }//GEN-LAST:event_AboutActionPerformed

    private void SuavizadoGaussianoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SuavizadoGaussianoActionPerformed
        
        if (img != null){

            // Creating radial buttons to use in the next interface:
            JRadioButton VButton = new JRadioButton("Vertical");
            JRadioButton HButton = new JRadioButton("Horizontal");
            JRadioButton VHButton = new JRadioButton("Ambas");

            ButtonGroup orientationBGroup = new ButtonGroup();
            orientationBGroup.add(VButton);
            orientationBGroup.add(HButton);
            orientationBGroup.add(VHButton);
            VHButton.setSelected(true);         // "Ambas" is the default button.

            JPanel panel = new JPanel();
            panel.add(VButton);
            panel.add(HButton);
            panel.add(VHButton);

            Object[] params = {"Tamaño del kernel: ", kernelSizeSlider, "Orientación:", panel};
            Object[] options = {"Aceptar", "Cancelar"};
            int result = JOptionPane.showOptionDialog(  ScrollPanePanel,
                                                        params,
                                                        "Opciones de Suavizado Gaussiano",
                                                        JOptionPane.YES_NO_OPTION,
                                                        JOptionPane.QUESTION_MESSAGE,
                                                        null,           // Don't use a custom Icon
                                                        options,        // The strings of buttons
                                                        options[0]);    // Default button title

            // Getting the orientation string from the radiobutton group.
            String orientation = getSelectedButtonText(orientationBGroup);

            //JOptionPane.showMessageDialog(this, "Tamaño Kernel: " + kernelSizeSlider.getValue() + "\nOrientación: " + orientation);

            //If the operation was canceled do nothing.
            if (result == JOptionPane.NO_OPTION){
                return;
            }

            // Parameters for the Gaussian Blur function
            int[] kernel = getGaussianKernel(kernelSizeSlider.getValue());
            int kSize = kernel.length;
            int kValue = 0;
            for (int i : kernel)
                kValue += i;    // Counting the sum of all the numbers in the kernel.
            boolean Vert = false;
            boolean Horiz = false;
            switch(orientation){
                case "Horizontal":
                    Horiz = true;
                    break;
                case "Vertical":
                    Vert = true;
                    break;
                default:
                    Vert = true;
                    Horiz = true;
            }

            try{
                GaussianBlurController(kernel, kSize, kValue, Vert, Horiz);
            }catch(RuntimeException re){
                JOptionPane.showMessageDialog(this, "¡ERROR: Ha ocurrido una excepción:\n" + re.getMessage() );
                return;
            }

            // Setting the image format since if it was binary it would become grayscale.
            if(format == 1)
                format = 2; // grayscale

            ImageIcon icon = new ImageIcon(img);
            // Adding the ImageIcon to the Label.
            imglabel.setIcon( icon );
            //Aligning the image to the center.
            imglabel.setHorizontalAlignment(JLabel.CENTER);
            //Adding the label to the Scrolling pane.
            jScrollPane.getViewport().add(imglabel);
            // Repainting the scroll pane to update the changes
            jScrollPane.repaint();
            // Recounting colors
            countUniqueColors();
            // Updating status bar.
            Estado.setText("Aplicando Suavizado Gaussiano | Colores Únicos en imagen: " + colorsCounter);
        }else{
            JOptionPane.showMessageDialog(this, "¡ERROR: Cargue una imagen primero!");
        }
    }//GEN-LAST:event_SuavizadoGaussianoActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ImageEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ImageEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ImageEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ImageEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            new ImageEditor().setVisible(true);
        });
        
        
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem About;
    private javax.swing.JMenuItem AbrirArchivo;
    private javax.swing.JMenu Ayuda;
    private javax.swing.JPanel BarraEstado;
    private javax.swing.JPanel BarraEstadoPanel;
    private javax.swing.JMenuItem BlancoNegro;
    private javax.swing.JMenuItem CompresionRLE;
    private javax.swing.JMenuItem EscalaDeGrises;
    private javax.swing.JLabel Estado;
    private javax.swing.JMenuItem GuardarBMP;
    private javax.swing.JMenu GuardarNetpbm;
    private javax.swing.JMenu MenuArchivo;
    private javax.swing.JMenuBar MenuBar;
    private javax.swing.JMenu MenuEditar;
    private javax.swing.JMenu MenuFiltros;
    private javax.swing.JMenuItem Negativo;
    private javax.swing.JMenuItem Readme;
    private javax.swing.JMenu Rotacion;
    private javax.swing.JMenuItem Rotar90CCW;
    private javax.swing.JMenuItem Rotar90CW;
    private javax.swing.JPanel ScrollPanePanel;
    private javax.swing.JMenuItem SinCompresion;
    private javax.swing.JMenuItem SuavizadoGaussiano;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JScrollPane jScrollPane;
    // End of variables declaration//GEN-END:variables

}